{"version":3,"sources":["webpack:///webpack/bootstrap fbba1fe11e03cc752bc2","webpack:///./~/axios/lib/utils.js","webpack:///./~/axios/lib/defaults.js","webpack:///./~/fast-json-patch/lib/helpers.js","webpack:///./~/json-patch-queue/src/index.js","webpack:///./~/axios/lib/adapters/xhr.js","webpack:///./~/axios/lib/cancel/Cancel.js","webpack:///./~/axios/lib/cancel/isCancel.js","webpack:///./~/axios/lib/core/createError.js","webpack:///./~/axios/lib/helpers/bind.js","webpack:///./~/deep-equal/index.js","webpack:///./~/fast-json-patch/lib/core.js","webpack:///(webpack)/~/process/browser.js","webpack:///./src/palindrom.js","webpack:///./~/axios/index.js","webpack:///./~/axios/lib/axios.js","webpack:///./~/axios/lib/cancel/CancelToken.js","webpack:///./~/axios/lib/core/Axios.js","webpack:///./~/axios/lib/core/InterceptorManager.js","webpack:///./~/axios/lib/core/dispatchRequest.js","webpack:///./~/axios/lib/core/enhanceError.js","webpack:///./~/axios/lib/core/settle.js","webpack:///./~/axios/lib/core/transformData.js","webpack:///./~/axios/lib/helpers/btoa.js","webpack:///./~/axios/lib/helpers/buildURL.js","webpack:///./~/axios/lib/helpers/combineURLs.js","webpack:///./~/axios/lib/helpers/cookies.js","webpack:///./~/axios/lib/helpers/isAbsoluteURL.js","webpack:///./~/axios/lib/helpers/isURLSameOrigin.js","webpack:///./~/axios/lib/helpers/normalizeHeaderName.js","webpack:///./~/axios/lib/helpers/parseHeaders.js","webpack:///./~/axios/lib/helpers/spread.js","webpack:///./~/deep-equal/lib/is_arguments.js","webpack:///./~/deep-equal/lib/keys.js","webpack:///./~/fast-json-patch/lib/duplex.js","webpack:///./~/json-patch-ot-agent/src/json-patch-ot-agent.js","webpack:///./~/json-patch-ot/src/json-patch-ot.js","webpack:///./~/json-patch-queue/src/json-patch-queue-synchronous.js","webpack:///./~/json-patch-queue/src/json-patch-queue.js","webpack:///./~/jsonpatcherproxy/src/jsonpatcherproxy.js","webpack:///(webpack)/buildin/global.js","webpack:///./package.json","webpack:///./src/palindrom-dom.js","webpack:///external \"URL\"","webpack:///external \"WebSocket\""],"names":[],"mappings":";4BACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,KAIA,2CAGA,aAGA,OACA,OAIA,IAzBA,eA4BA,MAGA,mBAA2C,CAAc,QAGzD,qBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,+BChEA,aAgBA,aACA,OACA,4BAOA,CAmEA,aACA,kBACA,kBAOA,CA+BA,aACA,OACA,+BAOA,CA0DA,eAEA,cAKA,6CAEA,SAGA,KAEA,qBAAmC,OAAO,IAC1C,gBAIA,sBACA,wCACA,uBAIA,SAkBA,CACA,YACA,gBAEA,6BACA,qBAIA,SAEA,QARA,sBAQuC,OAAO,IAC9C,MAEA,gBACA,QASA,CAxQA,QAMA,sBAOA,SAuQA,UACA,CACA,UACA,cA/PA,WACA,OACA,kCAOA,EAuPA,WAtPA,WACA,iDACA,SAOA,EA8OA,kBA7OA,WACA,IACA,GAMA,sDALA,mBAEA,0CAEA,cAQA,EA+NA,SA9NA,WACA,OACA,kBAOA,EAsNA,SArNA,WACA,OACA,kBAOA,EA6MA,WACA,YA7MA,WACA,OACA,qBAOA,EAqMA,OA1LA,WACA,OACA,2BAOA,EAkLA,OAjLA,WACA,OACA,2BAOA,EAyKA,OAxKA,WACA,OACA,2BAOA,EAgKA,aACA,SAtJA,WACA,kBACA,KAOA,EA8IA,kBA7IA,WACA,wDACA,gBAOA,EAqIA,qBAnHA,UACA,CACA,MACA,4BACA,8BAEA,yCAaA,EAiGA,UACA,QACA,OA9BA,eACA,CAQA,wBAPA,SACA,qBAIA,QACA,MAuBA,KAxIA,WACA,4CACA,GAcA,6CClLA,CAUA,eACA,oCACA,qBAEA,mBAZA,QACA,OAEA,MACA,eAEA,yDAqBA,SAbA,UACA,IACA,GAQA,MANA,mCAGA,4BAEA,QAJG,IAOH,CAGA,kCACA,YACA,kBACA,iBACA,oBACA,eACA,aAIA,cACA,uBAEA,SACA,0BACA,qDAEA,cACA,iBACA,uCAGA,eAEA,iCAEA,uBACA,eACA,OACA,QACA,QAAO,SAAY,CACnB,CACA,CACA,QAEA,WAEA,iBACA,4BAEA,iCAEA,4BACA,gBACA,KACA,GAEA,UACA,CAGA,qDAEA,6CACA,GACA,aAAC,GAED,4CACA,gBACA,QAAC,GAED,2CCjFA,eACA,UACA,UAEA,aACA,qBACA,mBACA,UAAuB,MAAiB,OACxC,SAEA,KACA,QACA,WACA,mBAEA,WACA,aACA,QACA,UAGA,QACA,SAyCA,aACA,6BAEA,wDACA,MAWA,eACA,IACA,UACA,kBACA,IACA,qBAEA,OACA,4BACA,QACA,mBAGA,KAEA,OACA,GAgBA,aACA,IACA,WAEA,SACA,cACA,4BAA6C,OAAS,IACtD,SACA,MAIA,kBACA,6BACA,SACA,SAA2B,EAAmB,IAC9C,WACA,OAKA,SACA,SAhJA,yCACA,aACmB,MAAsB,aACzC,2CADA,qEAEA,MAMA,oCAIA,mBAoBA,EAOA,cAWA,EACA,WAXA,WACA,QACA,cACA,gCACA,kBACA,kBACA,MACA,QAEA,YAiBA,EAKA,UAnBA,WACA,QAGA,KAFA,MACA,YAEA,QACA,2BACA,CACA,IACA,QACA,CACA,QACA,CACA,UAYA,EAKA,sBAIA,wBAHA,WACA,2CACA,MAmBA,sBAWA,EAGA,QAbA,aACA,IACA,YAEA,UACA,UACA,uBAEA,kCACA,OA6BA,iBACA,iBACA,sBAEA,QACA,aACA,eACA,YACA,aACA,iBACA,MACA,CACA,MATA,SASC,SACD,+BC5JA,CACA,QACA,YAEA,UAAkB,uGCNlB,CAEA,QACA,OACA,QACA,QACA,QACA,QACA,8EAEA,qBACA,iCACA,SACA,SAEA,UACA,wBAGA,yBACA,kBACA,qBAKA,QACA,yBACA,oDACA,2BACA,oBACA,iBACA,SACA,6BACA,yBAIA,UACA,wBACA,sBACA,gCACA,MAEA,qDAGA,kCAGA,uBACA,QAQA,oDAKA,oGACA,iDACA,0BACA,CAEA,oCACA,iDACA,WACA,UACA,SAGA,WAGA,WACA,KAGA,sBAGA,KAGA,sBACA,IAGA,wBACA,6CAGA,mBACA,IAKA,2BACA,SAGA,uCACA,wBAIA,+BAEA,kBAGA,IACA,iDACA,wBAEA,uCAGA,QAEA,qBAIA,KACA,oBAIA,sBACA,gBACA,kBACA,YAAO,SACP,IACA,wBAEA,OAIA,CACA,yEAIA,6DACA,+CAGA,oBAEA,mDAKA,OACA,QAEA,OACA,KAGA,GACA,eAIA,QACA,OACA,iCCzKA,aACA,aACA,MACA,UAEA,+BACA,gDACA,KAEA,0BAEA,yBClBA,aAEA,qBACA,eACA,8BCJA,aAEA,QAUA,IACA,2BACA,UACA,gBACA,0BChBA,aAEA,uBACA,kBACA,2BACA,UAAmB,MAAiB,OACpC,SAEA,sBACA,UACA,oBCmBA,aACA,kBACA,WAEA,aACA,+BACA,uDAGA,0CAEA,6BAEA,iBACA,OACA,WACA,KAEA,sCAGA,YACA,aAGA,WACA,YACA,QAEA,kBACA,KACA,KAEA,gCACA,eAAe,MAAc,OAC7B,mBAEA,SACA,QACA,IACA,OACA,OACA,IAAG,SACH,CACA,QAGA,gBACA,OAEA,eACA,SAEA,kBAAyB,EAAQ,KACjC,aACA,KAIA,wBAAyB,EAAQ,KACjC,SACA,qBAEA,0BACA,SA7FA,sBACA,UACA,QAEA,+BACA,YAEA,MAGG,uCACH,sBAIG,qCACH,oBAWA,wBAFA,wBCiEA,eACA,IACA,MAEA,eAAkC,WAClC,cACA,UACA,MAeA,mBACA,QAAuC,SACvC,UAAoC,SAEpC,UACA,+BAGA,UAIA,gBACA,OAA2B,CAC3B,kBACA,aAGA,uBAFA,WAGA,iBAIA,uBAHA,QACA,8BAGA,cAMA,2BALA,MACA,kBAEA,8BAGA,iBACA,cACA,gFAEA,OAEA,SADA,eAEA,IACA,gBAIA,SAHA,wBACA,UAGA,cAIA,SAHA,UAIA,8HAGA,WAGA,SACA,KAEA,SAEA,kBAMA,GACA,EACA,YAPA,aACA,KACA,MACA,MACA,aASA,2BACA,MAEA,QACA,YACA,kCAEA,UACA,QAEA,MACA,gBAIA,QACA,qBACA,IACA,YAGA,qBACA,2MAEA,eACA,kBAGA,YACA,yBACA,yJAEA,sBACA,wBACA,gFAEA,OACA,QACA,CAEA,aACA,wBAEA,+BACA,eACA,wBACA,gFAEA,OACA,QAEA,GACA,IACA,CACA,EAeA,mBACA,CAEA,OAFoC,SACpC,gBAEA,wEAIA,iCAEA,iCACA,gBAA4C,OAAc,IAC1D,aACA,eAEA,YAEA,SADA,gBA2BA,mBACA,wCACA,mEAEA,8CACA,sGAEA,sCACA,+FAEA,iEAEA,2FAEA,wEACA,2IAEA,4FACA,6IAEA,4GACA,qIAEA,sDACA,qBACA,yBACA,sBACA,mBACA,yFAEA,kCACA,4CACA,oBACA,iGAGA,2EACA,OAAiC,uBACjC,kBACA,aACA,iIAEA,oCAEA,EASA,iBACA,IACA,WACA,wEAEA,yBAEA,uCAEA,WACA,GACA,eAA2B,MAAqB,OAChD,MAEA,gBACA,CACA,SACA,mBACA,eAGA,SAEA,OACA,EAvXA,MAAqB,CACrB,eACA,kBACA,OACA,SACA,SACA,8BACA,cAOA,WACA,MACA,oBACA,kBACA,MAAgB,CAChB,cACA,wBACA,OACA,kBACA,MAAgB,eAChB,UACA,yBACA,OACA,sBACA,MAAgB,eAChB,UACA,sBAIA,gBAEA,cAEA,yBAAsD,uBAAgC,OACtF,mBAAkC,yBAClC,UAAgB,eAChB,UACA,sBACA,gBAEA,iBAAkC,iCAClC,gBAAgB,CAChB,cACA,sBACA,OAAgB,gCAChB,OACA,sBACA,mBACA,KAAgB,CAChB,cAGA,KACA,oBACA,UACA,+BAGA,iBAGA,MAAgB,eAChB,QACA,wBACA,kBACA,SAAgB,yBAChB,GACA,yBACA,OACA,sBACA,MAAgB,eAChB,UACA,SACA,YACA,YACA,YASA,MASA,EAaA,oBAkIA,EAaA,iBAmBA,EASA,aAQA,EAOA,aAdA,aACA,OACA,iBACA,gFAEA,gBACA,aAsDA,EAOA,YA0BA,yBCxXA,CAWA,YACA,iBACA,mCACA,YACA,iBACA,oCACA,CAoBA,aACA,QAEA,+BAGA,mBACA,oBACA,wBAEA,MAEA,YACA,EAAK,SACL,IAEA,sBACA,EAAS,SAET,sBACA,EACA,CAGA,EACA,aACA,QAEA,mBAGA,iCACA,sBACA,aAEA,mBAEA,OACA,KAAK,SACL,IAEA,eACA,OAAS,SAGT,eACA,OACA,CAIA,EAMA,YACA,CAGA,OACA,OACA,WAEA,aAEA,IACA,QAEA,KAEA,YACA,CAGA,aACA,KAEA,iBACA,UACA,KACA,IACA,KAEA,eAGA,SACA,MACA,MACA,GACA,KACA,KACA,MAgBA,eACA,MACA,WACA,QAWA,cAhKA,GAQA,SADA,sBAUA,IACA,GACA,8BAIA,YAAK,SACL,CACA,GACA,IACA,GACA,gCAIA,cAAK,SACL,CACA,GACA,CAAC,KAqDD,GAGA,GAFA,KACA,UA0CA,sBACA,8BACA,MACA,6BAAuB,cAAsB,OAC7C,WAGA,oBACA,YACA,iBAEA,IAEA,EAKA,0BACA,0BACA,QACA,kBACA,aACA,SACA,UACA,UAAqB,GACrB,cAIA,OACA,gBACA,SACA,QACA,mBACA,uBACA,SACA,oBACA,wBAEA,sBAAqC,WAErC,oBACA,iBACA,qCAEA,gBAA2B,YAC3B,kBACA,iBACA,mCACA,kBAA4B,OAAU,oBCvLtC,aAIA,CAEA,KAAO,cAAuB,cAC9B,QACA,QACA,GACA,iCACA,mBACA,QACA,QACA,QACA,YAOA,gBAEA,aACA,MAEA,gBACC,eAED,kBAIG,UAEH,aACA,cAiBA,2BACA,KAaA,kBACA,aAOA,CACA,MACA,EACA,KACA,kBACA,IAEA,IAbA,GACA,EACA,EACA,OAEA,aASA,CACA,QACA,GACA,QACA,EAEA,MACA,KACA,OAEA,kBAKA,+BAIA,KACA,IACA,KACA,IAKA,wBACA,GACA,EACA,GAMA,4BACA,CACA,IACA,GAGA,EACA,GAUA,oBACA,IACA,GAKA,uBAIA,sBACA,MACA,aACA,GACA,KAKA,4BACA,CACA,kBAIA,0BACA,GACA,KACA,GACA,KAKA,+BACA,CACA,kBACA,UACA,OAKA,gBACA,CACA,kBACA,KACA,kBACA,IACA,CAEA,aACA,8DACA,CAEA,oBA0QA,0CACA,KACA,QACA,mCAEA,eACA,EAEA,cACA,GACA,yBACA,QACA,cAEA,KAOA,gBAwBA,aAEA,oBACA,eAEA,qBACA,oCAGA,uBAEA,qBACA,OACA,EAEA,cACA,CAEA,+BAEA,SAEA,cACA,UACA,+BACA,UACA,EAMA,kBAkUA,iBAA+C,OAAS,IACxD,WAEA,QAOA,gBACA,SACA,YACA,qBACA,UACA,qBAIA,YACA,kDAEA,mBACA,KACA,YAA8J,qJAI9J,IAEA,gBACA,cACA,eACA,wBACA,uBACA,UACA,SAGA,IA31BA,yBAEA,iCAEA,eASA,aA+IA,CAUA,8BAEA,MAEA,8DACA,iCAGA,MAGA,kBACA,sBACA,mBACA,8BACA,yBACA,0BACA,qCACA,KACA,mBACA,aACA,aACA,oBACA,aAEA,gBACA,WACA,2BAEA,UACA,IACA,WAGO,eACP,oCAEA,YACA,YAEA,aACA,4BACA,OAEA,iBACA,CACA,EACA,QAAW,mBACX,kBAGA,eAQA,QAEA,iCACA,iCACA,mCACO,UACP,wBACA,uDACA,kBACA,SACA,EACA,OACA,KAOA,YACA,CAEA,UACA,iBACA,WAUA,oBACA,6BACA,mBAEA,QAEA,eACA,8BACA,6BACA,iBACA,IACA,0BACA,sBACA,oCACA,KACA,wBACA,+CAEA,aAIA,sBACA,YACA,8DACA,WAGA,6BACA,MACA,wBACA,MACA,uBAEA,aACA,OACA,OAGA,gBACA,YACA,mDACA,WACA,mBACA,cAGA,UACA,6BACS,SACT,eAEA,mBACA,CAEA,qBACA,aAEA,MACA,8BACA,YACA,kBACA,SAGA,KAEA,eACA,gBACA,KAEA,wJACA,oBAGA,gBACA,4CACA,sBACA,wMACA,cAA2C,sBAG3C,SACA,sDACA,KAEA,wBAEA,MACA,0CAEA,0BAEA,eAUA,eACA,mBACA,MACA,QAGA,yBAGA,mCAEA,iBACA,6CAEA,YACA,iBACA,CAGA,wBACA,CAGA,YACA,YACA,MACA,uCACA,cACA,cACA,WAEA,SACA,aACA,WACA,eACW,SAEX,QACA,2DAAoF,SACpF,KAEA,oDACA,QACA,MACA,aACA,CACA,aACA,aAKA,cAEA,QACA,aAGA,SAuBA,iBACA,MACA,WACA,OAGA,QACA,CACA,QAGA,WACA,iCACA,MAEA,SACA,iCAEA,KAFsB,sBACtB,UAIA,SAsCA,qBACA,CACA,QAEA,eAIA,SAEA,UACA,4BACA,WAGA,4DACA,8BAGA,8BACA,mBACA,WAIA,2JAEA,yBAEA,UACA,oCACA,uCACA,sDACA,iBACA,wCAEA,UACA,kBACA,KAIA,uGACA,sCACA,2CACA,iDACA,6EACA,iCACA,oDACA,2CACA,uBACA,iCACA,uCACA,iCAEA,mDACA,YACA,WACA,6BAGA,mCACA,eACA,6BACA,qBACA,sCAIA,UACA,qBAGA,mBACA,MACA,OACA,YACA,8CACA,4BACA,sCACA,+BACA,iCACA,qCAKA,+BAEA,IACA,mBACA,2CAWA,eACA,GACA,WACA,MACA,gCACA,sDACA,QAEA,QACA,WACA,0BACA,sDACA,QAKA,kCA1BA,aACA,WACA,MACA,oDACA,QAGA,oBAoBA,WACA,uCAGA,SACA,KACA,iBACA,UACA,WAEA,2IACA,mBACA,qBACA,YACA,oBACA,cACA,cACA,OACA,GACA,QAEA,0BAEA,KAGA,4BAEA,uDACA,cAEA,6BACA,oBAGA,oCACA,MACA,CACA,QACA,OACA,iBACA,4BAEA,EAGA,uBACA,cAEA,UACA,8CACA,cACA,cAEA,YACA,8CACA,aACA,cAEA,qBAEA,GACA,sBAEA,wCACA,SACA,kCAEA,+BACA,cACA,gBAEA,8BAEA,IACA,MACA,+BAGA,eAEA,4BAEA,+BAEA,iCAGA,oBAGA,mCACA,wBACA,IAAW,SAEX,6DAA8E,SAC9E,QACA,6BACA,QACA,CACA,MACA,mBAAO,SACP,SACA,MAGA,iBAFA,kCAIA,OACA,aACA,GAEA,sBACA,SAEA,eAEA,iCAKA,wBACA,gBACA,wBACA,qBAKA,wBACA,gBACA,wBACA,wBACA,wBAEA,wBAEA,eACA,kBACA,cAEA,iBACA,gCAEA,cAA0B,MAE1B,kBAA2C,uBAE3C,IAEA,0BACA,gBACA,wBAEA,OAEA,SACA,oCAGA,oBAKA,qBACA,sBAIA,4BAGA,yBAEA,sBACA,4BACA,uCAIA,gEAGA,YACA,sDAEA,QASA,EA2CA,SADA,UACC,KAED,YACA,oBACA,yDCx4BA,Y,qBCAA,aAaA,aACA,OACA,yBAGA,WAMA,oBAHA,eAEA,aAIA,CAzBA,QACA,OACA,OACA,QAOA,KAiBA,KACA,EAEA,QACA,oBACA,YACA,WAEA,EACA,cACA,oBACA,aAEA,GACA,iBACA,gBACA,QACA,eAEA,EAEA,UACA,qCCnDA,aAUA,aACA,IACA,yCAGA,mCACA,uCACA,CACA,GAEA,SACA,kBACA,GAKA,kBACA,aACA,QACA,EAIA,CAhCA,QAOA,GA0BA,uCACA,SACA,kBAEA,MAKA,EACA,mBACA,IACA,sBACA,CACA,GACA,SACA,CACA,QAEA,WAEA,6BCxDA,aAcA,aACA,MACA,6BACA,SACA,eAEA,MAMA,CAxBA,QACA,OACA,OACA,QACA,QACA,QAMA,IAcA,+BAGA,CACA,+BACA,eACK,cAGL,+BAAiD,QAGjD,0BACA,2BAIA,YACA,qBAEA,4DACA,yBACA,SAEA,iDACA,sBACA,SAEA,KACA,6BAGA,SACA,QAEA,EACA,6CAEA,6BACA,6BAAgD,MAChD,CACA,SAEA,QACA,CAAC,GAED,4CAEA,+BACA,6BAAgD,MAChD,CACA,SACA,MAEA,SACA,CAAC,GAED,6BCpFA,aAIA,YACA,MACA,WASA,CAbA,WAcA,6BACA,2BACA,CACA,YAEA,kCACA,CAMA,EACA,6BACA,MACA,+BAEA,KASA,EACA,+BACA,oCACA,CACA,UAEA,IACA,IAEA,6BCnDA,aAUA,aACA,GACA,2BAEA,kBAOA,CAnBA,QACA,OACA,QACA,OAIA,GAaA,qBACA,CAGA,iBAGA,mBACA,IACA,OACA,UAIA,8BACA,gBACA,uBACA,cAGA,eAEA,yEACA,UACA,UAGA,sBAEA,oCACA,CAUA,MAPA,aACA,IACA,OACA,UAGA,oBACG,aACH,OACA,QAGA,UACA,2BACA,aACA,gBACA,UAKA,6BACA,SACA,iBCpEA,aACA,2BACA,CAMA,SAJA,eAEA,UACA,+BCjBA,aAEA,QAQA,GACA,yBACA,gBAEA,iCACA,UAGA,uCACA,SACA,OAIA,SAPA,uBCjBA,aAEA,QASA,GACA,yBAEA,CAKA,8BAJA,GACA,MAEA,mBCdA,aAEA,YACA,cACA,uCACA,sBACA,mBACA,yCAwBA,UAtBA,WACA,CAIA,YAHA,SACA,OAMA,8FAEA,uBACA,SACA,wBACA,GACA,WAEA,YACA,GACA,CACA,2BCjCA,aAIA,aACA,OACA,uCACA,qBACA,oBACA,qBACA,oBACA,qBACA,qBACA,IAQA,CAnBA,WAoBA,yBAEA,IACA,GAGA,YACA,GACA,OACG,eACH,yBACG,eACH,IAEA,+BACA,WAIA,0BACA,gBAGA,SACA,eAGA,4BACA,GACA,cACS,gBACT,qBAEA,8BACA,KACA,GAEA,YACA,IAGA,CAIA,uCADA,wBC1DA,aACA,uBACA,kDACA,sBCXA,aAEA,WAEA,EACA,UAGA,iCACA,OACA,4BACA,IACA,mBAEA,yBACA,2CAGA,iBACA,oBAGA,aACA,oBAGA,aACA,eAGA,iCACA,KAEA,kBACA,wCAA0D,eAC1D,gDACA,IAEA,oBACA,sBACA,aAEA,EAGA,cACA,OACA,kBACA,iBAA6B,OAAa,KAC1C,oBAEA,EACA,iBC7CA,aACA,qBAIA,wCACA,0BCbA,aAEA,WAEA,EACA,UAIA,iCACA,cAWA,IAIA,+BACA,cAGA,qBAGA,UACA,QACA,qDACA,UACA,gDACA,uCACA,cACA,gBACA,cACA,6BACA,eAEA,SAEA,IA1BA,sCATA,oCACA,gCA0CA,iBACA,qBACA,6BACA,qBACA,IACA,CAGA,cACA,kBACA,CACA,QACA,CACA,qBCnEA,aAEA,WAEA,uBACA,0BACA,4BACA,gBACA,aAEA,MACA,qBCXA,aAEA,QAcA,GACA,qBACA,IAEA,GACA,EAIA,EANA,kDAOA,aACA,6BACA,kCAGA,uBAEA,SAGA,sBCfA,aACA,qBACA,mBACA,gBACA,OACA,kBCnBA,aACA,OACA,wDAGA,aACA,OACA,IACA,oBACA,kEACA,yDAEA,cAnBA,sCACA,uCACA,UAAC,IAED,kBAEA,cAKA,+BCPA,aACA,IACA,uBACA,QACA,SARA,YACA,6CAEA,0BCiCA,aACA,iBAA+C,OAAY,IAC3D,YACA,cAGA,MACA,eACA,2BAAqD,OAAY,IACjE,sBACA,mCAGA,SACA,eACA,2BAAqD,OAAY,IACjE,sBACA,aAIA,iCAHA,EAMA,CAgFA,aACA,QACA,WAA+C,OAAY,IAC3D,2BACA,GACA,KACA,KAEA,8BACA,cACA,+BAEA,iBACA,QAOA,MANA,gBACA,aACA,YAGA,eAIA,mBACA,IAGA,OACA,kCAEA,sBACA,mBACA,eACA,KAEA,gBAAoC,EAAQ,SAC5C,OACA,OACA,kFACA,OACA,sDACA,wBAGA,wBACA,QACA,YAAkC,0DAGlC,gBAEA,aAA0B,0BAC1B,yBAEA,IACA,mBAGA,mBAAmB,MAAoB,OACvC,MACA,4BACA,sBAA0B,iEAG1B,QAGA,CA/MA,MAAqB,CACrB,eAIA,OACA,OAEA,YACA,kCACA,0BACA,8BACA,wCACA,sBACA,cACA,UACA,WACA,8BACA,yBACA,4CACA,gDACA,GACA,kBACA,CAKA,kBAJA,MACA,kBACA,KACA,CAEA,gBACA,CAKA,oBAJA,MACA,gBACA,UACA,CACC,IA6BD,EAGA,UANA,aACA,GACA,aAyEA,EAGA,QAvEA,aACA,CAEA,GACA,KAEA,KAOA,OADA,UALA,WAGA,WAKA,YACA,eACA,gBACA,GACA,kBACA,qBACA,CACA,IACA,cACA,gBACA,aACA,aACA,EACA,oCACA,0CACA,qCACA,mCACA,uCACA,qCAGA,mDACA,oDACA,kDACA,sDACA,oDAGA,eACA,CAuBA,SAtBA,aACA,+BACA,CACA,oBACA,MACA,OACA,oCACA,gDACA,wCACA,sCACA,0CAGA,oDACA,oDACA,kDACA,sDAGA,gBACA,mBACA,eA2BA,EACA,WAmDA,UALA,aACA,IACA,MAEA,eADA,wBCnNA,GAEA,iCAiBA,eACA,yBACA,QACA,mBAKA,iBAEA,YACA,uCACA,0BACA,4BAMA,EACA,4BACA,eACA,aACA,IACA,iBACA,sBAEA,4CACA,QAEA,oBADA,SAUA,EACA,iCACA,eACA,QAEA,qCACA,oBAGA,eAOA,eACA,YACA,yBAGA,mCACA,eAGA,aAEA,cAGA,oBACA,MACA,EAKA,EACA,6BACA,+DACA,gBACA,2CACA,OAEA,IACA,oBACA,oBACA,0BCpGA,CAEA,gBAEA,kBA0HA,kBAGA,oBACA,gBACA,uBACA,SACA,uBACA,SAIA,MACA,cACA,QACA,qBACA,IACA,IA1IA,QACA,+BACA,IACA,iBAEA,iCACA,kBACA,YAEA,QACA,uCAEA,CACA,qBAGA,uDACA,+BAEA,iEACA,+BAIA,oCACA,aACA,+BAEA,qCACA,EACA,OACA,KAEA,eACA,eASA,SACA,QACA,IACA,qBAEA,QAEA,oBAKA,kDAIA,SACA,wBACA,kDAEA,+CACA,GACA,IAEA,KAIA,6BACA,aACA,uBACA,uBACA,MAIA,iBACA,SACA,EACA,OACA,KAEA,IACA,mCAEA,mBACA,mCAIA,UAEA,CACA,uBAEA,QAEA,SAQA,WACA,wBACA,iCAEA,+CACA,GAEA,KAGA,GAEA,GAmBA,QAGA,MACA,oBACA,oBACA,0BCpJA,CACA,uBAMA,MAOA,WAKA,gBAKA,mBAKA,aACA,QACA,EACA,oBASA,EACA,iCACA,eACA,gBAEA,WACA,SAEA,gBACA,YAIA,iBAEA,wBACE,8DAGF,eACA,0BACA,sBAIA,yCAEA,IAKA,EACA,4BACA,MACA,wBACA,GAaA,iBAZA,IACA,oBACA,uBAEA,eACA,kBACA,IACA,iBACA,+BAGA,OAGA,wCACA,eACA,KACA,aAEA,eACA,eACA,gDACA,OACA,WAEA,KACA,OACA,KAKA,EACA,6BACA,gDACA,kBACA,2CAEA,KAFe,sBACf,UAIA,IACA,oBAEA,oBACA,0BC3HA,CACA,uBAMA,MAMA,WAKA,4BAKA,qBAKA,QAKA,aAEA,QACA,EACA,yBAGA,EACA,0BAWA,EACA,iCACA,eACA,gBAEA,WACA,SAEA,gBACA,YAIA,iBAEA,8BACE,oEAGF,eACA,gCACA,sBAIA,+CAEA,IAKA,EACA,4BACA,MACA,6BACA,GAkBA,YAjBA,iBACA,IACA,iBACA,kCACG,GACH,IACA,oBACA,qBAGA,yBACA,IACA,oBACA,qBAGA,kBAGA,wCACA,eACA,KACA,aAEA,eACA,eACA,gDACA,OACA,WAEA,KACA,OACA,KAKA,EACA,6BACA,sDACA,iBACA,2CAEA,KAFe,sBACf,UAIA,IACA,oBAEA,oBACA,2BC1IA,aACA,kBAIA,cAaA,4BACA,uDACA,KACA,gBAQA,MACA,gCACA,YAEA,kBACA,8BAEA,oBACA,gBACA,WACA,KACA,OACA,EASA,oBACA,SAEA,eAEA,qCACA,+BAEA,4CACA,CACA,SAEA,QAWA,+BAYA,aACA,wBAKA,cACA,GACA,2CAEA,+BACA,CACA,SAEA,aAGA,8CACA,IACA,SAEA,iCAEA,0BAEA,iCAGA,iBAEA,oCAEA,wCAGA,iCACA,QACA,8CAGA,UAAK,KACL,2CAEA,2BAEA,gBACA,QACA,oDACA,mBAGA,aACA,OACA,iBACA,WAEA,SADA,oBASA,kBACA,6BACA,SACA,eAEA,6BACA,IAIA,YASA,YAEA,uCACA,kBACA,qDAGA,wBAEA,oBAMA,yBALA,IACA,SAGA,UAEA,CAEA,aACA,2BACA,gCACA,gCACA,eACA,OACA,cACA,aACA,2BACA,OACA,cAQA,gBACA,MACA,4BACA,2CACA,2BAEA,KACA,sBAGA,WACA,2BACA,kCACA,UACA,oBAKA,gCAKA,wBACA,KAEA,CAkJA,SAxWA,qBAXA,QACA,cACA,gCACA,kBACA,kBACA,MACA,QAEA,UACA,IAaA,qEA4MA,IACA,GAEA,iBACA,KACA,aACA,sCAEA,mBAEA,wBACA,kBAIA,0CAAiC,UAGjC,wCACA,WACA,KAEA,4CAIA,eACA,QACA,UACA,iCACA,oBAEA,gCACA,KAKA,mBACA,0BAEA,2CAQA,MACA,aACA,oCAGA,uCAGA,IAGA,YAFA,4BACA,UAMA,mCAEA,WACA,6BACA,MACA,GAEA,oKAIA,SACA,gBACA,gBACA,UACA,sBAIA,SACA,gBACA,gBACA,UACA,iCAGA,OACA,gBACA,mBACA,CACA,6BACA,2BACA,2BAEA,cAMA,mCACA,QACA,mBAEA,oEACA,mBAOA,wBACA,yDACA,qBACA,WAIA,iCACA,UACA,4BAEA,gGACA,OAIA,+BACA,uCACA,GACA,QACA,EAIA,qCACA,4DACA,KACA,GAIA,MACA,oBACA,uBCtYA,GAGA,aACA,OACA,KAAC,IAED,GAEA,0CACA,OAAC,SAED,CACA,4BACA,OAI4C,CAE5C,yBCpBA,EAA8jC,wsCCI9jC,CACA,UAEA,WAMA,kBACA,eACA,IACA,4BACA,OAGA,+DACA,0BAEA,mDACA,WACA,kBACA,KAIA,0GACA,MACA,mBACA,OAGA,EAEA,2CACA,8CACA,mDAEA,wCACA,SACA,KAEA,+KACA,gBAGA,eACA,iBACA,oCAGA,6BACA,iBACA,iCAEA,yBAEA,SACA,MACA,wDACA,sDAEA,6BACA,iBACA,oCAIA,6BACA,iBACA,iCAEA,yBACA,WACA,MAEA,2DACA,yDACA,6BACA,oBACA,oCAIA,6BACA,oBACA,iCAEA,yBA2CA,YACA,wBACA,qBACA,+CACA,EAEA,gBAEA,0BACA,WAGA,0BAEA,aAGA,gBAEA,UACA,2BAAuB,WAAuB,OAC9C,+BACA,KACA,QACA,KAGA,kCAEA,6BAIA,gCACA,aACA,wBACA,mBACA,uBACS,aACT,qBAEA,gBACA,CAEA,iBACA,yCACA,KAOA,4BACA,uBAEA,gCACA,OAMA,OACA,sBAGA,MACA,GACA,CACA,mCACA,kCAEA,IAGA,iCAGA,WACA,yBAEA,iCAEA,eAGA,MAQA,SAJA,cACA,WAEA,aACC,KAED,YACA,oBACA,qCC1OA,U,iBCAA,U","file":"dist/palindrom-dom.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 41);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fbba1fe11e03cc752bc2","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  typeof document.createElement -> undefined\n */\nfunction isStandardBrowserEnv() {\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined' &&\n    typeof document.createElement === 'function'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/utils.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/;\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      data = data.replace(PROTECTION_PREFIX, '');\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/defaults.js\n// module id = 1\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(obj, key) {\r\n    return _hasOwnProperty.call(obj, key);\r\n}\r\nexports.hasOwnProperty = hasOwnProperty;\r\nfunction _objectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        var keys = new Array(obj.length);\r\n        for (var k = 0; k < keys.length; k++) {\r\n            keys[k] = \"\" + k;\r\n        }\r\n        return keys;\r\n    }\r\n    if (Object.keys) {\r\n        return Object.keys(obj);\r\n    }\r\n    var keys = [];\r\n    for (var i in obj) {\r\n        if (hasOwnProperty(obj, i)) {\r\n            keys.push(i);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nexports._objectKeys = _objectKeys;\r\n;\r\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\r\nfunction _deepClone(obj) {\r\n    switch (typeof obj) {\r\n        case \"object\":\r\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n        case \"undefined\":\r\n            return null; //this is how JSON.stringify behaves for array items\r\n        default:\r\n            return obj; //no need to clone primitives\r\n    }\r\n}\r\nexports._deepClone = _deepClone;\r\n//3x faster than cached /^\\d+$/.test(str)\r\nfunction isInteger(str) {\r\n    var i = 0;\r\n    var len = str.length;\r\n    var charCode;\r\n    while (i < len) {\r\n        charCode = str.charCodeAt(i);\r\n        if (charCode >= 48 && charCode <= 57) {\r\n            i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.isInteger = isInteger;\r\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\r\nfunction escapePathComponent(path) {\r\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\r\n        return path;\r\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\nexports.escapePathComponent = escapePathComponent;\r\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\r\nfunction unescapePathComponent(path) {\r\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\nexports.unescapePathComponent = unescapePathComponent;\r\nfunction _getPathRecursive(root, obj) {\r\n    var found;\r\n    for (var key in root) {\r\n        if (hasOwnProperty(root, key)) {\r\n            if (root[key] === obj) {\r\n                return escapePathComponent(key) + '/';\r\n            }\r\n            else if (typeof root[key] === 'object') {\r\n                found = _getPathRecursive(root[key], obj);\r\n                if (found != '') {\r\n                    return escapePathComponent(key) + '/' + found;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n}\r\nexports._getPathRecursive = _getPathRecursive;\r\nfunction getPath(root, obj) {\r\n    if (root === obj) {\r\n        return '/';\r\n    }\r\n    var path = _getPathRecursive(root, obj);\r\n    if (path === '') {\r\n        throw new Error(\"Object not found in root\");\r\n    }\r\n    return '/' + path;\r\n}\r\nexports.getPath = getPath;\r\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\r\nfunction hasUndefined(obj) {\r\n    if (obj === undefined) {\r\n        return true;\r\n    }\r\n    if (obj) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0, len = obj.length; i < len; i++) {\r\n                if (hasUndefined(obj[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            var objKeys = _objectKeys(obj);\r\n            var objKeysLength = objKeys.length;\r\n            for (var i = 0; i < objKeysLength; i++) {\r\n                if (hasUndefined(obj[objKeys[i]])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.hasUndefined = hasUndefined;\r\nvar PatchError = (function (_super) {\r\n    __extends(PatchError, _super);\r\n    function PatchError(message, name, index, operation, tree) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.operation = operation;\r\n        this.tree = tree;\r\n    }\r\n    return PatchError;\r\n}(Error));\r\nexports.PatchError = PatchError;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fast-json-patch/lib/helpers.js\n// module id = 2\n// module chunks = 0","/**\r\n * version: 3.0.0-rc.0\r\n */\r\nvar queue = require(\"./json-patch-queue\");\r\nvar sync = require(\"./json-patch-queue-synchronous\");\r\n\r\nmodule.exports = { JSONPatchQueue: queue, JSONPatchQueueSynchronous: sync, /* Babel demands this */__esModule:  true };\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-patch-queue/src/index.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        if (request.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/adapters/xhr.js\n// module id = 4\n// module chunks = 0","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/cancel/Cancel.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/cancel/isCancel.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n @ @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, response);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/createError.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/bind.js\n// module id = 8\n// module chunks = 0","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/index.js\n// module id = 9\n// module chunks = 0","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nexports.JsonPatchError = helpers_1.PatchError;\r\nexports.deepClone = helpers_1._deepClone;\r\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\r\n/* The operations applicable to an object */\r\nvar objOps = {\r\n    add: function (obj, key, document) {\r\n        obj[key] = this.value;\r\n        return { newDocument: document };\r\n    },\r\n    remove: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        delete obj[key];\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    replace: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        obj[key] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: function (obj, key, document) {\r\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\r\n        var removed = getValueByPointer(document, this.path);\r\n        if (removed) {\r\n            removed = helpers_1._deepClone(removed);\r\n        }\r\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\r\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    copy: function (obj, key, document) {\r\n        var valueToCopy = getValueByPointer(document, this.from);\r\n        // enforce copy by value so further operations don't affect source (see issue #177)\r\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_1._deepClone(valueToCopy) });\r\n        return { newDocument: document };\r\n    },\r\n    test: function (obj, key, document) {\r\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\r\n    },\r\n    _get: function (obj, key, document) {\r\n        this.value = obj[key];\r\n        return { newDocument: document };\r\n    }\r\n};\r\n/* The operations applicable to an array. Many are the same as for the object */\r\nvar arrOps = {\r\n    add: function (arr, i, document) {\r\n        if (helpers_1.isInteger(i)) {\r\n            arr.splice(i, 0, this.value);\r\n        }\r\n        else {\r\n            arr[i] = this.value;\r\n        }\r\n        // this may be needed when using '-' in an array\r\n        return { newDocument: document, index: i };\r\n    },\r\n    remove: function (arr, i, document) {\r\n        var removedList = arr.splice(i, 1);\r\n        return { newDocument: document, removed: removedList[0] };\r\n    },\r\n    replace: function (arr, i, document) {\r\n        var removed = arr[i];\r\n        arr[i] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: objOps.move,\r\n    copy: objOps.copy,\r\n    test: objOps.test,\r\n    _get: objOps._get\r\n};\r\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\r\nfunction getValueByPointer(document, pointer) {\r\n    if (pointer == '') {\r\n        return document;\r\n    }\r\n    var getOriginalDestination = { op: \"_get\", path: pointer };\r\n    applyOperation(document, getOriginalDestination);\r\n    return getOriginalDestination.value;\r\n}\r\nexports.getValueByPointer = getValueByPointer;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\r\nfunction applyOperation(document, operation, validateOperation, mutateDocument) {\r\n    if (validateOperation === void 0) { validateOperation = false; }\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (typeof validateOperation == 'function') {\r\n            validateOperation(operation, 0, document, operation.path);\r\n        }\r\n        else {\r\n            validator(operation, 0);\r\n        }\r\n    }\r\n    /* ROOT OPERATIONS */\r\n    if (operation.path === \"\") {\r\n        var returnValue = { newDocument: document };\r\n        if (operation.op === 'add') {\r\n            returnValue.newDocument = operation.value;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'replace') {\r\n            returnValue.newDocument = operation.value;\r\n            returnValue.removed = document; //document we removed\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\r\n            if (operation.op === 'move') {\r\n                returnValue.removed = document;\r\n            }\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'test') {\r\n            returnValue.test = areEquals(document, operation.value);\r\n            if (returnValue.test === false) {\r\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n            }\r\n            returnValue.newDocument = document;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'remove') {\r\n            returnValue.removed = document;\r\n            returnValue.newDocument = null;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === '_get') {\r\n            operation.value = document;\r\n            return returnValue;\r\n        }\r\n        else {\r\n            if (validateOperation) {\r\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\r\n            }\r\n            else {\r\n                return returnValue;\r\n            }\r\n        }\r\n    } /* END ROOT OPERATIONS */\r\n    else {\r\n        if (!mutateDocument) {\r\n            document = helpers_1._deepClone(document);\r\n        }\r\n        var path = operation.path || \"\";\r\n        var keys = path.split('/');\r\n        var obj = document;\r\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\r\n        var len = keys.length;\r\n        var existingPathFragment = undefined;\r\n        var key = void 0;\r\n        var validateFunction = void 0;\r\n        if (typeof validateOperation == 'function') {\r\n            validateFunction = validateOperation;\r\n        }\r\n        else {\r\n            validateFunction = validator;\r\n        }\r\n        while (true) {\r\n            key = keys[t];\r\n            if (validateOperation) {\r\n                if (existingPathFragment === undefined) {\r\n                    if (obj[key] === undefined) {\r\n                        existingPathFragment = keys.slice(0, t).join('/');\r\n                    }\r\n                    else if (t == len - 1) {\r\n                        existingPathFragment = operation.path;\r\n                    }\r\n                    if (existingPathFragment !== undefined) {\r\n                        validateFunction(operation, 0, document, existingPathFragment);\r\n                    }\r\n                }\r\n            }\r\n            t++;\r\n            if (Array.isArray(obj)) {\r\n                if (key === '-') {\r\n                    key = obj.length;\r\n                }\r\n                else {\r\n                    if (validateOperation && !helpers_1.isInteger(key)) {\r\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\r\n                    } // only parse key when it's an integer for `arr.prop` to work\r\n                    else if (helpers_1.isInteger(key)) {\r\n                        key = ~~key;\r\n                    }\r\n                }\r\n                if (t >= len) {\r\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\r\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\r\n                    }\r\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            else {\r\n                if (key && key.indexOf('~') != -1) {\r\n                    key = helpers_1.unescapePathComponent(key);\r\n                }\r\n                if (t >= len) {\r\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            obj = obj[key];\r\n        }\r\n    }\r\n}\r\nexports.applyOperation = applyOperation;\r\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\r\nfunction applyPatch(document, patch, validateOperation, mutateDocument) {\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (!Array.isArray(patch)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n    }\r\n    if (!mutateDocument) {\r\n        document = helpers_1._deepClone(document);\r\n    }\r\n    var results = new Array(patch.length);\r\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\r\n        results[i] = applyOperation(document, patch[i], validateOperation);\r\n        document = results[i].newDocument; // in case root was replaced\r\n    }\r\n    results.newDocument = document;\r\n    return results;\r\n}\r\nexports.applyPatch = applyPatch;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\r\nfunction applyReducer(document, operation) {\r\n    var operationResult = applyOperation(document, operation);\r\n    if (operationResult.test === false) {\r\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n    }\r\n    return operationResult.newDocument;\r\n}\r\nexports.applyReducer = applyReducer;\r\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\r\nfunction validator(operation, index, document, existingPathFragment) {\r\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\r\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\r\n    }\r\n    else if (!objOps[operation.op]) {\r\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\r\n    }\r\n    else if (typeof operation.path !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\r\n        // paths that aren't empty string should start with \"/\"\r\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\r\n    }\r\n    else if (document) {\r\n        if (operation.op == \"add\") {\r\n            var pathLen = operation.path.split(\"/\").length;\r\n            var existingPathLen = existingPathFragment.split(\"/\").length;\r\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\r\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\r\n            if (operation.path !== existingPathFragment) {\r\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\r\n            var error = validate([existingValue], document);\r\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\r\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.validator = validator;\r\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\r\nfunction validate(sequence, document, externalValidator) {\r\n    try {\r\n        if (!Array.isArray(sequence)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n        if (document) {\r\n            //clone document and sequence so that we can safely try applying operations\r\n            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);\r\n        }\r\n        else {\r\n            externalValidator = externalValidator || validator;\r\n            for (var i = 0; i < sequence.length; i++) {\r\n                externalValidator(sequence[i], i, document, undefined);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof exports.JsonPatchError) {\r\n            return e;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.validate = validate;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fast-json-patch/lib/core.js\n// module id = 10\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/~/process/browser.js\n// module id = 11\n// module chunks = 0","/*! Palindrom \r\n * https://github.com/Palindrom/Palindrom\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\n\r\nconst { applyPatch, validate } = require('fast-json-patch');\r\nconst JSONPatcherProxy = require('jsonpatcherproxy');\r\nconst JSONPatchQueueSynchronous = require('json-patch-queue')\r\n  .JSONPatchQueueSynchronous;\r\nconst JSONPatchQueue = require('json-patch-queue').JSONPatchQueue;\r\nconst JSONPatchOT = require('json-patch-ot');\r\nconst JSONPatchOTAgent = require('json-patch-ot-agent');\r\nconst URL = require('./URL');\r\nconst axios = require('axios');\r\nconst version = require('../package.json').version;\r\n\r\n/* We are going to hand `websocket` lib as an external to webpack\r\n  (see: https://webpack.js.org/configuration/externals/), \r\n  this will make `w3cwebsocket` property `undefined`, \r\n  and this will lead Palindrom to use Browser's WebSocket when it is used \r\n  from the bundle. And use `websocket` lib in Node environment */\r\nconst NodeWebSocket = require('websocket').w3cwebsocket;\r\n\r\n/* this allows us to stub WebSockets */\r\nif (!global.WebSocket && NodeWebSocket) {\r\n  /* we are in production env */\r\n  var WebSocket = NodeWebSocket;\r\n} else if (global.WebSocket) {\r\n  /* we are in testing env */\r\n  var WebSocket = global.WebSocket;\r\n}\r\n/* else {\r\n    we are using Browser's WebSocket\r\n  } */\r\n\r\nconst Palindrom = (() => {\r\n  if (typeof global === 'undefined') {\r\n    if (typeof window !== 'undefined') {\r\n      /* incase neither window nor global existed, e.g React Native */\r\n      var global = window;\r\n    } else {\r\n      var global = {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replaces http and https to ws and wss in a URL and returns it as a string.\r\n   * @param  {String} remoteUrl HTTP remote address\r\n   * @return {String}           WS address\r\n   */\r\n  function toWebSocketURL(remoteUrl) {\r\n    /* replace 'http' strictly in the beginning of the string,\r\n    this covers http and https */\r\n    return remoteUrl.replace(/^http/i, 'ws');\r\n  }\r\n\r\n  /**\r\n   * @callback reconnectionCallback called when reconnection attempt is scheduled.\r\n   * It's called every second until reconnection attempt is made (`milliseconds` reaches 0)\r\n   * @param {number} milliseconds - number of milliseconds to next reconnection attempt. >= 0\r\n   */\r\n  /**\r\n   * @param {Function} reconnect used to perform reconnection. No arguments\r\n   * @param {reconnectionCallback} onReconnectionCountdown called to notify that reconnection attempt is scheduled\r\n   * @param {Function} onReconnectionEnd called to notify that reconnection attempt is not longer scheduled\r\n   * @constructor\r\n   */\r\n  function Reconnector(reconnect, onReconnectionCountdown, onReconnectionEnd) {\r\n    let intervalMs;\r\n    let timeToCurrentReconnectionMs;\r\n    let reconnectionPending;\r\n    let reconnection;\r\n    const defaultIntervalMs = 1000;\r\n\r\n    function reset() {\r\n      intervalMs = defaultIntervalMs;\r\n      timeToCurrentReconnectionMs = 0;\r\n      reconnectionPending = false;\r\n      clearTimeout(reconnection);\r\n      reconnection = null;\r\n    }\r\n\r\n    const step = () => {\r\n      if (timeToCurrentReconnectionMs == 0) {\r\n        onReconnectionCountdown(0);\r\n        reconnectionPending = false;\r\n        intervalMs *= 2;\r\n        reconnect();\r\n      } else {\r\n        onReconnectionCountdown(timeToCurrentReconnectionMs);\r\n        timeToCurrentReconnectionMs -= 1000;\r\n        setTimeout(step, 1000);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Notify Reconnector that connection error occurred and automatic reconnection should be scheduled.\r\n     */\r\n    this.triggerReconnection = () => {\r\n      if (reconnectionPending) {\r\n        return;\r\n      }\r\n      timeToCurrentReconnectionMs = intervalMs;\r\n      reconnectionPending = true;\r\n      step();\r\n    };\r\n\r\n    /**\r\n     * Reconnect immediately and reset all reconnection timers.\r\n     */\r\n    this.reconnectNow = () => {\r\n      timeToCurrentReconnectionMs = 0;\r\n      intervalMs = defaultIntervalMs;\r\n    };\r\n\r\n    /**\r\n     * Notify Reconnector that there's no need to do further actions (either connection has been established or a fatal error occured).\r\n     * Resets state of Reconnector\r\n     */\r\n    this.stopReconnecting = () => {\r\n      reset();\r\n      onReconnectionEnd();\r\n    };\r\n\r\n    // remember, we're still in constructor\r\n    reset();\r\n  }\r\n\r\n  /**\r\n   * Guarantees some communication to server and monitors responses for timeouts.\r\n   * @param sendHeartbeatAction will be called to send a heartbeat\r\n   * @param onError will be called if no response will arrive after `timeoutMs` since a message has been sent\r\n   * @param intervalMs if no request will be sent in that time, a heartbeat will be issued\r\n   * @param timeoutMs should a response fail to arrive in this time, `onError` will be called\r\n   * @constructor\r\n     */\r\n  function Heartbeat(sendHeartbeatAction, onError, intervalMs, timeoutMs) {\r\n    let scheduledSend;\r\n    let scheduledError;\r\n\r\n    /**\r\n     * Call this function at the beginning of operation and after successful reconnection.\r\n     */\r\n    this.start = function() {\r\n      if (scheduledSend) {\r\n        return;\r\n      }\r\n      scheduledSend = setTimeout(() => {\r\n        this.notifySend();\r\n        sendHeartbeatAction();\r\n      }, intervalMs);\r\n    };\r\n\r\n    /**\r\n     * Call this method just before a message is sent. This will prevent unnecessary heartbeats.\r\n     */\r\n    this.notifySend = function() {\r\n      clearTimeout(scheduledSend); // sending heartbeat will not be necessary until our response arrives\r\n      scheduledSend = null;\r\n      if (scheduledError) {\r\n        return;\r\n      }\r\n      scheduledError = setTimeout(() => {\r\n        scheduledError = null;\r\n        onError(); // timeout has passed and response hasn't arrived\r\n      }, timeoutMs);\r\n    };\r\n\r\n    /**\r\n     * Call this method when a message arrives from other party. Failing to do so will result in false positive `onError` calls\r\n     */\r\n    this.notifyReceive = function() {\r\n      clearTimeout(scheduledError);\r\n      scheduledError = null;\r\n      this.start();\r\n    };\r\n\r\n    /**\r\n     * Call this method to disable heartbeat temporarily. This is *not* automatically called when error is detected\r\n     */\r\n    this.stop = () => {\r\n      clearTimeout(scheduledSend);\r\n      scheduledSend = null;\r\n      clearTimeout(scheduledError);\r\n      scheduledError = null;\r\n    };\r\n  }\r\n\r\n  function NoHeartbeat() {\r\n    this.start = this.stop = this.notifySend = this.notifyReceive = () => {};\r\n  }\r\n\r\n  class PalindromNetworkChannel {\r\n    constructor(\r\n      palindrom,\r\n      remoteUrl,\r\n      useWebSocket,\r\n      onReceive,\r\n      onSend,\r\n      onConnectionError,\r\n      onSocketOpened,\r\n      onFatalError,\r\n      onStateChange\r\n    ) {\r\n      // TODO(tomalec): to be removed once we will achieve better separation of concerns\r\n      this.palindrom = palindrom;\r\n\r\n      if (typeof window !== 'undefined' && window.location) {\r\n        this.remoteUrl = new URL(remoteUrl, window.location.href);\r\n      } else {\r\n        // in Node, URL is absolute\r\n        this.remoteUrl = new URL(remoteUrl);\r\n      }\r\n\r\n      onReceive && (this.onReceive = onReceive);\r\n      onSend && (this.onSend = onSend);\r\n      onConnectionError && (this.onConnectionError = onConnectionError);\r\n      onFatalError && (this.onFatalError = onFatalError);\r\n      onStateChange && (this.onStateChange = onStateChange);\r\n      onSocketOpened && (this.onSocketOpened = onSocketOpened);\r\n      this._useWebSocket = useWebSocket || false;\r\n    }\r\n    get useWebSocket() {\r\n      return this._useWebSocket;\r\n    }\r\n    set useWebSocket(newValue) {\r\n      this._useWebSocket = newValue;\r\n\r\n      if (newValue == false) {\r\n        if (this._ws) {\r\n          this._ws.onclose = () => {\r\n            //overwrites the previous onclose\r\n            this._ws = null;\r\n          };\r\n          this._ws.close();\r\n        }\r\n        // define wsUrl if needed\r\n      } else if (!this.wsUrl) {\r\n        this.wsUrl = toWebSocketURL(this.remoteUrl.href);\r\n      }\r\n      return this.useWebSocket;\r\n    }\r\n\r\n    establish(bootstrap) {\r\n      establish(this, this.remoteUrl.href, null, bootstrap);\r\n    }\r\n\r\n    reestablish(pending, bootstrap) {\r\n      establish(\r\n        this,\r\n        `${this.remoteUrl.href}/reconnect`,\r\n        JSON.stringify(pending),\r\n        bootstrap\r\n      );\r\n    }\r\n\r\n    /**\r\n     * Send any text message by currently established channel\r\n     * @TODO: handle readyState 2-CLOSING & 3-CLOSED (tomalec)\r\n     * @param  {String} msg message to be sent\r\n     * @return {PalindromNetworkChannel}     self\r\n     */\r\n    send(msg) {\r\n      // send message only if there is a working ws connection\r\n      if (this.useWebSocket && this._ws && this._ws.readyState === 1) {\r\n        this._ws.send(msg);\r\n        this.onSend(msg, this._ws.url, 'WS');\r\n      } else {\r\n        const url = this.remoteUrl.href;\r\n        this.xhr(url, 'application/json-patch+json', msg, (res, method) => {\r\n          this.onReceive(res.data, url, method);\r\n        });\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * Callback function that will be called once message from remote comes.\r\n     * @param {String} [JSONPatch_sequences] message with Array of JSONPatches that were send by remote.\r\n     * @return {[type]} [description]\r\n     */\r\n    onReceive() /*String_with_JSONPatch_sequences*/ {\r\n    }\r\n\r\n    onSend() {}\r\n    onStateChange() {}\r\n    upgrade(msg) {}\r\n\r\n    /**\r\n     * Send a WebSocket upgrade request to the server.\r\n     * For testing purposes WS upgrade url is hard-coded now in Palindrom (replace __default/ID with __default/ID)\r\n     * In future, server should suggest the WebSocket upgrade URL\r\n     * @TODO:(tomalec)[cleanup] hide from public API.\r\n     * @param {Function} [callback] Function to be called once connection gets opened.\r\n     * @returns {WebSocket} created WebSocket\r\n     */\r\n    webSocketUpgrade(onSocketOpenCallback) {\r\n      this.wsUrl = toWebSocketURL(this.remoteUrl.href);\r\n      const upgradeURL = this.wsUrl;\r\n\r\n      closeWsIfNeeded(this);\r\n\r\n      this._ws = new WebSocket(upgradeURL);\r\n      this._ws.onopen = event => {\r\n        this.onStateChange(this._ws.readyState, upgradeURL);\r\n        onSocketOpenCallback && onSocketOpenCallback(event);\r\n      };\r\n      this._ws.onmessage = event => {\r\n        const parsedMessage = JSON.parse(event.data);\r\n        this.onReceive(parsedMessage, this._ws.url, 'WS');\r\n      };\r\n      this._ws.onerror = event => {\r\n        this.onStateChange(this._ws.readyState, upgradeURL, event.data);\r\n\r\n        if (!this.useWebSocket) {\r\n          return;\r\n        }\r\n\r\n        const m = {\r\n          statusText: 'WebSocket connection could not be made.',\r\n          readyState: this._ws.readyState,\r\n          url: upgradeURL\r\n        };\r\n\r\n        this.onFatalError(m, upgradeURL, 'WS');\r\n      };\r\n      this._ws.onclose = event => {\r\n        this.onStateChange(\r\n          this._ws.readyState,\r\n          upgradeURL,\r\n          null,\r\n          event.code,\r\n          event.reason\r\n        );\r\n\r\n        const m = {\r\n          statusText: 'WebSocket connection closed.',\r\n          readyState: this._ws.readyState,\r\n          url: upgradeURL,\r\n          statusCode: event.code,\r\n          reason: event.reason\r\n        };\r\n\r\n        if (event.reason) {\r\n          this.onFatalError(m, upgradeURL, 'WS');\r\n        } else if (!event.wasClean) {\r\n          this.onConnectionError();\r\n        }\r\n      };\r\n    }\r\n\r\n    getPatchUsingHTTP(href) {\r\n      return this.xhr(\r\n        href,\r\n        'application/json-patch+json',\r\n        null,\r\n        (res, method) => {\r\n          this.onReceive(res.data, href, method);\r\n        },\r\n        true\r\n      );\r\n    }\r\n\r\n    changeState(href) {\r\n      console.warn(\r\n        \"Palindrom: changeState was renamed to `getPatchUsingHTTP`, and they're both not recommended to use, please use `PalindromDOM.morphUrl` instead\"\r\n      );\r\n      return this.getPatchUsingHTTP(href);\r\n    }\r\n\r\n    // TODO:(tomalec)[cleanup] hide from public API.\r\n    setRemoteUrl(remoteUrl) {\r\n      if (this.remoteUrlSet && this.remoteUrl && this.remoteUrl != remoteUrl) {\r\n        throw new Error(\r\n          `Session lost. Server replied with a different session ID that was already set. \\nPossibly a server restart happened while you were working. \\nPlease reload the page.\\n\\nPrevious session ID: ${this\r\n            .remoteUrl}\\nNew session ID: ${remoteUrl}`\r\n        );\r\n      }\r\n      this.remoteUrlSet = true;\r\n      this.remoteUrl = new URL(remoteUrl, this.remoteUrl.href);\r\n    }\r\n\r\n    handleResponseHeader(res) {\r\n      /* Axios always returns lowercase headers */\r\n      const location =\r\n        res.headers && (res.headers['x-location'] || res.headers['location']);\r\n      if (location) {\r\n        this.setRemoteUrl(location);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Internal method to perform XMLHttpRequest\r\n     * @param url (Optional) URL to send the request. If empty string, undefined or null given - the request will be sent to window location\r\n     * @param accept (Optional) HTTP accept header\r\n     * @param data (Optional) Data payload\r\n     * @param [callback(response)] callback to be called in context of palindrom with response as argument\r\n     * @returns {XMLHttpRequest} performed XHR\r\n     */\r\n    xhr(url, accept, data, callback, setReferer) {\r\n      const method = data ? 'PATCH' : 'GET';\r\n      const headers = {};\r\n      let requestPromise;\r\n\r\n      if (data) {\r\n        headers['Content-Type'] = 'application/json-patch+json';\r\n      }\r\n      if (accept) {\r\n        headers['Accept'] = accept;\r\n      }\r\n      if (this.remoteUrl && setReferer) {\r\n        headers['X-Referer'] = this.remoteUrl.pathname;\r\n      }\r\n      if (method === 'GET') {\r\n        requestPromise = axios.get(url, {\r\n          headers\r\n        });\r\n      } else {\r\n        requestPromise = axios.patch(url, data, {\r\n          headers\r\n        });\r\n      }\r\n      requestPromise\r\n        .then(res => {\r\n          this.handleResponseHeader(res);\r\n          callback && callback.call(this.palindrom, res, method);\r\n        })\r\n        .catch(error => {\r\n          const res = error.response;\r\n\r\n          if (res) {\r\n            var statusCode = res.status;\r\n            var statusText = res.statusText;\r\n            var reason = res.data;\r\n          } else {\r\n            // no sufficient error information, we need to create on our own\r\n            var statusCode = -1;\r\n            var statusText = `An unknown network error has occurred. Raw message: ${error.message}`;\r\n            var reason = 'Maybe you lost connection with the server';\r\n            // log it for verbosity\r\n            console.error(error);\r\n          }\r\n          this.onFatalError(\r\n            {\r\n              statusCode,\r\n              statusText,\r\n              reason\r\n            },\r\n            url,\r\n            method\r\n          );\r\n        });\r\n\r\n      this.onSend(data, url, method);\r\n    }\r\n  }\r\n  // TODO: auto-configure here #38 (tomalec)\r\n  function establish(network, url, body, bootstrap) {\r\n    return network.xhr(url, 'application/json', body, res => {\r\n      bootstrap(res.data);\r\n      if (network.useWebSocket) {\r\n        network.webSocketUpgrade(network.onSocketOpened);\r\n      }\r\n    });\r\n  }\r\n\r\n  function closeWsIfNeeded(network) {\r\n    if (network._ws) {\r\n      network._ws.onclose = () => {};\r\n      network._ws.close();\r\n      network._ws = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Non-queuing object that conforms JSON-Patch-Queue API\r\n   * @param {Object} obj target object where patches are applied\r\n   * @param {Function} apply function to apply received patch, must return the object in its final state\r\n   */\r\n  class NoQueue {\r\n    constructor(obj, apply) {\r\n      this.obj = obj;\r\n      this.apply = apply;\r\n    }\r\n\r\n    /** just forward message */\r\n    send(msg) {\r\n      return msg;\r\n    }\r\n\r\n    /** Apply given JSON Patch sequence immediately */\r\n    receive(sequence) {\r\n      return (this.obj = this.apply(this.obj, sequence));\r\n    }\r\n\r\n    reset(newState) {\r\n      const patch = [{ op: 'replace', path: '', value: newState }];\r\n      return (this.obj = this.apply(this.obj, patch));\r\n    }\r\n  }\r\n\r\n  function connectToRemote(palindrom, reconnectionFn) {\r\n    // if we lose connection at this point, the connection we're trying to establish should trigger onError\r\n    palindrom.heartbeat.stop();\r\n\r\n    reconnectionFn(function bootstrap(json) {\r\n      palindrom.reconnector.stopReconnecting();\r\n\r\n      if (palindrom.debug) {\r\n        palindrom.remoteObj = JSON.parse(JSON.stringify(json));\r\n      }\r\n\r\n      palindrom.queue.reset(json);\r\n\r\n      palindrom.heartbeat.start();\r\n    });\r\n  }\r\n\r\n  function makeInitialConnection(palindrom) {\r\n    connectToRemote(\r\n      palindrom,\r\n      palindrom.network.establish.bind(palindrom.network)\r\n    );\r\n  }\r\n\r\n  function makeReconnection(palindrom) {\r\n    connectToRemote(palindrom, bootstrap => {\r\n      palindrom.network.reestablish(palindrom.queue.pending, bootstrap);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Defines a connection to a remote PATCH server, serves an object that is persistent between browser and server.\r\n   * @param {Object} [options] map of arguments. See README.md for description\r\n   */\r\n  class Palindrom {\r\n    /**\r\n     * Palindrom version\r\n     */\r\n    static get version() { \r\n      return version\r\n    }\r\n\r\n    constructor(options) {\r\n      /**\r\n       * Palindrom instance version\r\n       */\r\n      this.version = version;\r\n\r\n      if (typeof options !== 'object') {\r\n        throw new TypeError(\r\n          'Palindrom constructor requires an object argument.'\r\n        );\r\n      }\r\n      if (!options.remoteUrl) {\r\n        throw new TypeError('remoteUrl is required');\r\n      }\r\n\r\n      if (options.ignoreAdd) {\r\n        throw new TypeError(\r\n          'Palindrom: `ignoreAdd` is removed in favour of local state objects. see https://github.com/Palindrom/Palindrom/issues/136'\r\n        );\r\n      }\r\n\r\n      this.debug = options.debug != undefined ? options.debug : true;\r\n\r\n      const noop = function noOpFunction() {};\r\n\r\n      this.isObserving = false;\r\n      this.onLocalChange = options.onLocalChange || noop;\r\n      this.onRemoteChange = options.onRemoteChange || noop;\r\n      this.onStateReset = options.onStateReset || options.callback || noop;\r\n      this.filterLocalChange =\r\n        options.filterLocalChange || (operation => operation);\r\n\r\n      if (options.callback) {\r\n        console.warn(\r\n          'Palindrom: options.callback is deprecated. Please use `onStateReset` instead'\r\n        );\r\n      }\r\n\r\n      this.onPatchReceived = options.onPatchReceived || noop;\r\n      this.onPatchSent = options.onPatchSent || noop;\r\n      this.onSocketStateChanged = options.onSocketStateChanged || noop;\r\n      this.onConnectionError = options.onConnectionError || noop;\r\n      this.retransmissionThreshold = options.retransmissionThreshold || 3;\r\n      this.onReconnectionCountdown = options.onReconnectionCountdown || noop;\r\n      this.onReconnectionEnd = options.onReconnectionEnd || noop;\r\n      this.onSocketOpened = options.onSocketOpened || noop;\r\n      this.onIncomingPatchValidationError =\r\n        options.onIncomingPatchValidationError || noop;\r\n      this.onOutgoingPatchValidationError =\r\n        options.onOutgoingPatchValidationError || noop;\r\n\r\n      this.reconnector = new Reconnector(\r\n        () => makeReconnection(this),\r\n        this.onReconnectionCountdown,\r\n        this.onReconnectionEnd\r\n      );\r\n\r\n      if (options.pingIntervalS) {\r\n        const intervalMs = options.pingIntervalS * 1000;\r\n        this.heartbeat = new Heartbeat(\r\n          this.ping.bind(this),\r\n          this.handleConnectionError.bind(this),\r\n          intervalMs,\r\n          intervalMs\r\n        );\r\n      } else {\r\n        this.heartbeat = new NoHeartbeat();\r\n      }\r\n\r\n      this.network = new PalindromNetworkChannel(\r\n        this, // palindrom instance TODO: to be removed, used for error reporting\r\n        options.remoteUrl,\r\n        options.useWebSocket || false, // useWebSocket\r\n        this.handleRemoteChange.bind(this), //onReceive\r\n        this.onPatchSent.bind(this), //onSend,\r\n        this.handleConnectionError.bind(this), //onConnectionError,\r\n        this.onSocketOpened.bind(this),\r\n        this.handleFatalError.bind(this), //onFatalError,\r\n        this.onSocketStateChanged.bind(this) //onStateChange\r\n      );\r\n      /**\r\n       * how many OT operations are there in each patch 0, 1 or 2\r\n       */\r\n      this.OTPatchIndexOffset = 0;\r\n      // choose queuing engine\r\n      if (options.localVersionPath) {\r\n        if (!options.remoteVersionPath) {\r\n          this.OTPatchIndexOffset = 1;\r\n          // just versioning\r\n          this.queue = new JSONPatchQueueSynchronous(\r\n            this.obj,\r\n            options.localVersionPath,\r\n            this.validateAndApplySequence.bind(this),\r\n            options.purity\r\n          );\r\n        } else {\r\n          this.OTPatchIndexOffset = 2;\r\n          // double versioning or OT\r\n          this.queue = options.ot\r\n            ? new JSONPatchOTAgent(\r\n                this.obj,\r\n                JSONPatchOT.transform,\r\n                [options.localVersionPath, options.remoteVersionPath],\r\n                this.validateAndApplySequence.bind(this),\r\n                options.purity\r\n              )\r\n            : new JSONPatchQueue(\r\n                this.obj,\r\n                [options.localVersionPath, options.remoteVersionPath],\r\n                this.validateAndApplySequence.bind(this),\r\n                options.purity\r\n              ); // full or noop OT\r\n        }\r\n      } else {\r\n        // no queue - just api\r\n        this.queue = new NoQueue(\r\n          this.obj,\r\n          this.validateAndApplySequence.bind(this)\r\n        );\r\n      }\r\n      makeInitialConnection(this);\r\n    }\r\n    set ignoreAdd(newValue) {\r\n      throw new TypeError(\r\n        \"Palindrom: Can't set `ignoreAdd`, it is removed in favour of local state objects. see https://github.com/Palindrom/Palindrom/issues/136\"\r\n      );\r\n    }\r\n    get useWebSocket() {\r\n      return this.network.useWebSocket;\r\n    }\r\n    set useWebSocket(newValue) {\r\n      this.network.useWebSocket = newValue;\r\n    }\r\n    ping() {\r\n      sendPatches(this, []); // sends empty message to server\r\n    }\r\n\r\n    prepareProxifiedObject(obj) {\r\n      if (!obj) {\r\n        obj = {};\r\n      }\r\n      /* wrap a new object with a proxy observer */\r\n      this.jsonPatcherProxy = new JSONPatcherProxy(obj);\r\n\r\n      const proxifiedObj = this.jsonPatcherProxy.observe(false, operation => {\r\n        const filtered = this.filterLocalChange(operation);\r\n        // totally ignore falsy (didn't pass the filter) JSON Patch operations\r\n        filtered && this.handleLocalChange(filtered);\r\n      });\r\n\r\n      /* make it read-only and expose it as `obj` */\r\n      Object.defineProperty(this, 'obj', {\r\n        get() {\r\n          return proxifiedObj;\r\n        },\r\n        set() {\r\n          throw new Error('palindrom.obj is readonly');\r\n        },\r\n        /* so that we can redefine it */\r\n        configurable: true\r\n      });\r\n      /* JSONPatcherProxy default state is observing */\r\n      this.isObserving = true;\r\n    }\r\n\r\n    observe() {\r\n      this.jsonPatcherProxy && this.jsonPatcherProxy.resume();\r\n      this.isObserving = true;\r\n    }\r\n\r\n    unobserve() {\r\n      this.jsonPatcherProxy && this.jsonPatcherProxy.pause();\r\n      this.isObserving = false;\r\n    }\r\n\r\n    handleLocalChange(operation) {\r\n      // it's a single operation, we need to check only it's value\r\n      operation.value &&\r\n        findRangeErrors(operation.value, this.onOutgoingPatchValidationError);\r\n\r\n      const patches = [operation];\r\n      if (this.debug) {\r\n        this.validateSequence(this.remoteObj, patches);\r\n      }\r\n      sendPatches(this, this.queue.send(patches));\r\n      this.onLocalChange(patches);\r\n    }\r\n\r\n    validateAndApplySequence(tree, sequence) {\r\n      // we don't want this changes to generate patches since they originate from server, not client\r\n      try {\r\n        this.unobserve();\r\n        const results = applyPatch(tree, sequence, this.debug);\r\n        // notifications have to happen only where observe has been re-enabled\r\n        // otherwise some listener might produce changes that would go unnoticed\r\n        this.observe();\r\n        // the state was fully replaced\r\n        if (results.newDocument !== tree) {\r\n          // object was reset, proxify it again\r\n          this.prepareProxifiedObject(results.newDocument);\r\n\r\n          this.queue.obj = this.obj;\r\n\r\n          // validate json response\r\n          findRangeErrors(this.obj, this.onIncomingPatchValidationError);\r\n\r\n          //notify people about it\r\n          try {\r\n            this.onStateReset(this.obj);\r\n          } catch (error) {\r\n            // to prevent the promise's catch from swallowing errors inside onStateReset\r\n            error.message = `Palindrom: Error inside onStateReset callback: ${error.message}`;\r\n            this.onConnectionError(error);\r\n            console.error(error);\r\n          }\r\n        }\r\n        this.onRemoteChange(sequence, results);\r\n      } catch (error) {\r\n        if (this.debug) {\r\n          this.onIncomingPatchValidationError(error);\r\n          return;\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n      return this.obj;\r\n    }\r\n\r\n    validateSequence(tree, sequence) {\r\n      const error = validate(sequence, tree);\r\n      if (error) {\r\n        this.onOutgoingPatchValidationError(error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Handle an error which is probably caused by random disconnection\r\n     */\r\n    handleConnectionError() {\r\n      this.heartbeat.stop();\r\n      this.reconnector.triggerReconnection();\r\n    }\r\n\r\n    /**\r\n     * Handle an error which probably won't go away on itself (basically forward upstream)\r\n     */\r\n    handleFatalError(data, url, method) {\r\n      this.heartbeat.stop();\r\n      this.reconnector.stopReconnecting();\r\n      if (this.onConnectionError) {\r\n        this.onConnectionError(data, url, method);\r\n      }\r\n    }\r\n\r\n    reconnectNow() {\r\n      this.reconnector.reconnectNow();\r\n    }\r\n\r\n    showWarning(heading, description) {\r\n      if (this.debug && global.console && console.warn) {\r\n        if (description) {\r\n          heading += ` (${description})`;\r\n        }\r\n        console.warn(`Palindrom warning: ${heading}`);\r\n      }\r\n    }\r\n\r\n    handleRemoteChange(data, url, method) {\r\n      this.heartbeat.notifyReceive();\r\n      const patches = data || []; // fault tolerance - empty response string should be treated as empty patch array\r\n\r\n      validateNumericsRangesInPatch(\r\n        patches,\r\n        this.onIncomingPatchValidationError,\r\n        this.OTPatchIndexOffset\r\n      );\r\n\r\n      if (patches.length === 0) {\r\n        // ping message\r\n        return;\r\n      }\r\n\r\n      if (this.onPatchReceived) {\r\n        this.onPatchReceived(data, url, method);\r\n      }\r\n\r\n      // apply only if we're still watching\r\n      if (!this.isObserving) {\r\n        return;\r\n      }\r\n      this.queue.receive(patches);\r\n      if (\r\n        this.queue.pending &&\r\n        this.queue.pending.length &&\r\n        this.queue.pending.length > this.retransmissionThreshold\r\n      ) {\r\n        // remote counterpart probably failed to receive one of earlier messages, because it has been receiving\r\n        // (but not acknowledging messages for some time\r\n        this.queue.pending.forEach(sendPatches.bind(null, this));\r\n      }\r\n\r\n      if (this.debug) {\r\n        this.remoteObj = JSON.parse(JSON.stringify(this.obj));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterates a JSON-Patch, traversing every patch value looking for out-of-range numbers\r\n   * @param {JSONPatch} patch patch to check\r\n   * @param {Function} errorHandler the error handler callback\r\n   * @param {*} startFrom the index where iteration starts\r\n   */\r\n  function validateNumericsRangesInPatch(patch, errorHandler, startFrom) {\r\n    for (let i = startFrom, len = patch.length; i < len; i++) {\r\n      findRangeErrors(patch[i].value, errorHandler);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Traverses/checks value looking for out-of-range numbers, throws a RangeError if it finds any\r\n   * @param {*} val value \r\n   * @param {Function} errorHandler \r\n   */\r\n  function findRangeErrors(val, errorHandler) {\r\n    const type = typeof val;\r\n    if (type == 'object') {\r\n      for (const key in val) {\r\n        if (val.hasOwnProperty(key)) {\r\n          findRangeErrors(val[key], errorHandler);\r\n        }\r\n      }\r\n    } else if (\r\n      type === 'number' &&\r\n      (val > Number.MAX_SAFE_INTEGER || val < Number.MIN_SAFE_INTEGER)\r\n    ) {\r\n      errorHandler(\r\n        new RangeError(\r\n          `A number that is either bigger than Number.MAX_INTEGER_VALUE or smaller than Number.MIN_INTEGER_VALUE has been encountered in a patch, value is: ${val}`\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  function sendPatches(palindrom, patches) {\r\n    const txt = JSON.stringify(patches);\r\n    palindrom.unobserve();\r\n    palindrom.heartbeat.notifySend();\r\n    palindrom.network.send(txt);\r\n    palindrom.observe();\r\n  }\r\n\r\n  /* backward compatibility */\r\n  global.Puppet = Palindrom;\r\n\r\n  return Palindrom;\r\n})();\r\n\r\nmodule.exports = Palindrom;\r\nmodule.exports.default = Palindrom;\r\nmodule.exports.__esModule = true;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/palindrom.js\n// module id = 12\n// module chunks = 0","module.exports = require('./lib/axios');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/index.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/axios.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/cancel/CancelToken.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar defaults = require('./../defaults');\nvar utils = require('./../utils');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/Axios.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/InterceptorManager.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/dispatchRequest.js\n// module id = 18\n// module chunks = 0","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n @ @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.response = response;\n  return error;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/enhanceError.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response\n    ));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/settle.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/core/transformData.js\n// module id = 21\n// module chunks = 0","'use strict';\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/btoa.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/buildURL.js\n// module id = 23\n// module chunks = 0","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/combineURLs.js\n// module id = 24\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/cookies.js\n// module id = 25\n// module chunks = 0","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/isAbsoluteURL.js\n// module id = 26\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/isURLSameOrigin.js\n// module id = 27\n// module chunks = 0","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/normalizeHeaderName.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/parseHeaders.js\n// module id = 29\n// module chunks = 0","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/axios/lib/helpers/spread.js\n// module id = 30\n// module chunks = 0","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/is_arguments.js\n// module id = 31\n// module chunks = 0","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/keys.js\n// module id = 32\n// module chunks = 0","var equalsOptions = { strict: true };\r\nvar _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = require('./helpers');\r\nvar core_1 = require('./core');\r\n/* export all core functions */\r\nvar core_2 = require('./core');\r\nexports.applyOperation = core_2.applyOperation;\r\nexports.applyPatch = core_2.applyPatch;\r\nexports.applyReducer = core_2.applyReducer;\r\nexports.getValueByPointer = core_2.getValueByPointer;\r\nexports.validate = core_2.validate;\r\nexports.validator = core_2.validator;\r\n/* export some helpers */\r\nvar helpers_2 = require('./helpers');\r\nexports.JsonPatchError = helpers_2.PatchError;\r\nexports.deepClone = helpers_2._deepClone;\r\nexports.escapePathComponent = helpers_2.escapePathComponent;\r\nexports.unescapePathComponent = helpers_2.unescapePathComponent;\r\nvar beforeDict = [];\r\nvar Mirror = (function () {\r\n    function Mirror(obj) {\r\n        this.observers = [];\r\n        this.obj = obj;\r\n    }\r\n    return Mirror;\r\n}());\r\nvar ObserverInfo = (function () {\r\n    function ObserverInfo(callback, observer) {\r\n        this.callback = callback;\r\n        this.observer = observer;\r\n    }\r\n    return ObserverInfo;\r\n}());\r\nfunction getMirror(obj) {\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === obj) {\r\n            return beforeDict[i];\r\n        }\r\n    }\r\n}\r\nfunction getObserverFromMirror(mirror, callback) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].callback === callback) {\r\n            return mirror.observers[j].observer;\r\n        }\r\n    }\r\n}\r\nfunction removeObserverFromMirror(mirror, observer) {\r\n    for (var j = 0, length = mirror.observers.length; j < length; j++) {\r\n        if (mirror.observers[j].observer === observer) {\r\n            mirror.observers.splice(j, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Detach an observer from an object\r\n */\r\nfunction unobserve(root, observer) {\r\n    observer.unobserve();\r\n}\r\nexports.unobserve = unobserve;\r\n/**\r\n * Observes changes made to an object, which can then be retrieved using generate\r\n */\r\nfunction observe(obj, callback) {\r\n    var patches = [];\r\n    var root = obj;\r\n    var observer;\r\n    var mirror = getMirror(obj);\r\n    if (!mirror) {\r\n        mirror = new Mirror(obj);\r\n        beforeDict.push(mirror);\r\n    }\r\n    else {\r\n        observer = getObserverFromMirror(mirror, callback);\r\n    }\r\n    if (observer) {\r\n        return observer;\r\n    }\r\n    observer = {};\r\n    mirror.value = helpers_1._deepClone(obj);\r\n    if (callback) {\r\n        observer.callback = callback;\r\n        observer.next = null;\r\n        var dirtyCheck = function () {\r\n            generate(observer);\r\n        };\r\n        var fastCheck = function () {\r\n            clearTimeout(observer.next);\r\n            observer.next = setTimeout(dirtyCheck);\r\n        };\r\n        if (typeof window !== 'undefined') {\r\n            if (window.addEventListener) {\r\n                window.addEventListener('mouseup', fastCheck);\r\n                window.addEventListener('keyup', fastCheck);\r\n                window.addEventListener('mousedown', fastCheck);\r\n                window.addEventListener('keydown', fastCheck);\r\n                window.addEventListener('change', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.attachEvent('onmouseup', fastCheck);\r\n                document.documentElement.attachEvent('onkeyup', fastCheck);\r\n                document.documentElement.attachEvent('onmousedown', fastCheck);\r\n                document.documentElement.attachEvent('onkeydown', fastCheck);\r\n                document.documentElement.attachEvent('onchange', fastCheck);\r\n            }\r\n        }\r\n    }\r\n    observer.patches = patches;\r\n    observer.object = obj;\r\n    observer.unobserve = function () {\r\n        generate(observer);\r\n        clearTimeout(observer.next);\r\n        removeObserverFromMirror(mirror, observer);\r\n        if (typeof window !== 'undefined') {\r\n            if (window.removeEventListener) {\r\n                window.removeEventListener('mouseup', fastCheck);\r\n                window.removeEventListener('keyup', fastCheck);\r\n                window.removeEventListener('mousedown', fastCheck);\r\n                window.removeEventListener('keydown', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.detachEvent('onmouseup', fastCheck);\r\n                document.documentElement.detachEvent('onkeyup', fastCheck);\r\n                document.documentElement.detachEvent('onmousedown', fastCheck);\r\n                document.documentElement.detachEvent('onkeydown', fastCheck);\r\n            }\r\n        }\r\n    };\r\n    mirror.observers.push(new ObserverInfo(callback, observer));\r\n    return observer;\r\n}\r\nexports.observe = observe;\r\n/**\r\n * Generate an array of patches from an observer\r\n */\r\nfunction generate(observer) {\r\n    var mirror;\r\n    for (var i = 0, length = beforeDict.length; i < length; i++) {\r\n        if (beforeDict[i].obj === observer.object) {\r\n            mirror = beforeDict[i];\r\n            break;\r\n        }\r\n    }\r\n    _generate(mirror.value, observer.object, observer.patches, \"\");\r\n    if (observer.patches.length) {\r\n        core_1.applyPatch(mirror.value, observer.patches);\r\n    }\r\n    var temp = observer.patches;\r\n    if (temp.length > 0) {\r\n        observer.patches = [];\r\n        if (observer.callback) {\r\n            observer.callback(temp);\r\n        }\r\n    }\r\n    return temp;\r\n}\r\nexports.generate = generate;\r\n// Dirty check if obj is different from mirror, generate patches and update mirror\r\nfunction _generate(mirror, obj, patches, path) {\r\n    if (obj === mirror) {\r\n        return;\r\n    }\r\n    if (typeof obj.toJSON === \"function\") {\r\n        obj = obj.toJSON();\r\n    }\r\n    var newKeys = helpers_1._objectKeys(obj);\r\n    var oldKeys = helpers_1._objectKeys(mirror);\r\n    var changed = false;\r\n    var deleted = false;\r\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\r\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\r\n        var key = oldKeys[t];\r\n        var oldVal = mirror[key];\r\n        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\r\n            var newVal = obj[key];\r\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null) {\r\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_1.escapePathComponent(key));\r\n            }\r\n            else {\r\n                if (oldVal !== newVal) {\r\n                    changed = true;\r\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_1.escapePathComponent(key) });\r\n            deleted = true; // property has been deleted\r\n        }\r\n    }\r\n    if (!deleted && newKeys.length == oldKeys.length) {\r\n        return;\r\n    }\r\n    for (var t = 0; t < newKeys.length; t++) {\r\n        var key = newKeys[t];\r\n        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\r\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Create an array of patches from the differences in two objects\r\n */\r\nfunction compare(tree1, tree2) {\r\n    var patches = [];\r\n    _generate(tree1, tree2, patches, '');\r\n    return patches;\r\n}\r\nexports.compare = compare;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fast-json-patch/lib/duplex.js\n// module id = 33\n// module chunks = 0","if(typeof JSONPatchQueue === 'undefined') {\r\n\tif(typeof require !== 'undefined') {\r\n\t\tvar JSONPatchQueue = require('json-patch-queue').JSONPatchQueue;\r\n\t}\r\n\telse {\r\n\t\tthrow new Error('You need to reference JSONPatchQueue before JSONPatchOTAgent');\r\n\t}\r\n}\r\n\r\n/**\r\n * [JSONPatchOTAgent description]\r\n * @param {Object} obj The target object where patches are applied\r\n * @param {Function} transform function(seqenceA, sequences) that transforms `seqenceA` against `sequences`.\r\n * @param {Array<JSON-Pointer>} versionPaths JSON-Pointers to version numbers [local, remote]\r\n * @param {function} apply apply(JSONobj, JSONPatchSequence) function to apply JSONPatch to object. Must return the final state of the object.\r\n * @param {Boolean} purity \r\n * @constructor\r\n * @extends {JSONPatchQueue}\r\n * @version: 2.0.0-rc.0\r\n */\r\nvar JSONPatchOTAgent = function(obj, transform, versionPaths, apply, purity){\r\n\tJSONPatchQueue.call(this, obj, versionPaths, apply, purity);\r\n\tthis.transform = transform;\r\n\t/**\r\n\t * History of performed JSON Patch sequences that might not yet be acknowledged by Peer\r\n\t * @type {Array<JSONPatch>}\r\n\t */\r\n\tthis.pending = [];\r\n\r\n};\r\nJSONPatchOTAgent.prototype = Object.create(JSONPatchQueue.prototype);\r\nJSONPatchOTAgent.prototype.constructor = JSONPatchOTAgent;\r\nJSONPatchOTAgent.prototype.ackLocalVersion = 0;\r\n\r\n/**\r\n * Wraps JSON Patch sequence with version related operation objects\r\n * @param  {JSONPatch} sequence JSON Patch sequence to wrap\r\n * @return {VersionedJSONPatch}\r\n */\r\nJSONPatchOTAgent.prototype.send = function(sequence){\r\n\tvar newSequence = sequence.slice(0);\r\n\tnewSequence.unshift({ // test for conflict resolutions\r\n\t\top: \"test\",\r\n\t\tpath: this.remotePath,\r\n\t\tvalue: this.remoteVersion\r\n\t});\r\n\tvar versionedJSONPatch = JSONPatchQueue.prototype.send.call(this, newSequence);\r\n\tthis.pending.push(versionedJSONPatch);\r\n    return versionedJSONPatch;\r\n};\r\n\r\n\r\n/**\r\n * Process received versioned JSON Patch\r\n * Adds to queue, transform and apply when applicable.\r\n * @param  {Object} obj object to apply patches to\r\n * @param  {JSONPatch} versionedJsonPatch patch to be applied\r\n * @param  {Function} [applyCallback] optional `function(object, consecutiveTransformedPatch)` to be called when applied, must return the final state of the object, if not given #apply will be called\r\n */\r\nJSONPatchOTAgent.prototype.receive = function(versionedJsonPatch, applyCallback){\r\n\tvar apply = applyCallback || this.apply,\r\n\t\tqueue = this;\r\n\r\n\treturn JSONPatchQueue.prototype.receive.call(this, versionedJsonPatch,\r\n\t\tfunction applyOT(obj, remoteVersionedJsonPatch){\r\n\t\t\t// console.log(\"applyPatch\", queue, arguments);\r\n\t        // transforming / applying\r\n\t        var consecutivePatch = remoteVersionedJsonPatch.slice(0);\r\n\r\n\t        // shift first operation object as it should contain test for our local version.\r\n\t        // ! We assume correct sequence structure, and queuing applied before.\r\n\t        //\r\n\t        // Latest local version acknowledged by remote\r\n\t        // Thanks to the queue version may only be higher or equal to current.\r\n\t        var localVersionAckByRemote = consecutivePatch.shift().value;\r\n\t        var ackDistance = localVersionAckByRemote - queue.ackLocalVersion;\r\n\t        queue.ackLocalVersion = localVersionAckByRemote;\r\n\r\n\t        //clear pending operations\r\n\t        queue.pending.splice(0,ackDistance);\r\n\t        if(queue.pending.length){// is there any pending local operation?\r\n\t            // => Remote sent us something based on outdated versionDistance\r\n\t            // console.info(\"Transformation needed\", consecutivePatch, 'by', queue.nonAckList);\r\n\t            consecutivePatch = queue.transform(\r\n\t                    consecutivePatch,\r\n\t                    queue.pending\r\n\t                );\r\n\t\t\t}\r\n\t\t\treturn queue.obj = apply(queue.obj, consecutivePatch);\r\n\t\t});\r\n};\r\n\r\n/**\r\n * Reset queue internals and object to new, given state\r\n * @param newState versioned object representing desired state along with versions\r\n */\r\nJSONPatchOTAgent.prototype.reset = function(newState){\r\n\tthis.ackLocalVersion = JSONPatchQueue.getPropertyByJsonPointer(newState, this.localPath);\r\n\tthis.pending = [];\r\n\treturn this.obj = JSONPatchQueue.prototype.reset.call(this, newState);\r\n};\r\nif(typeof module !== 'undefined') {\r\n\tmodule.exports = JSONPatchOTAgent;\r\n\tmodule.exports.default = JSONPatchOTAgent;\r\n\tmodule.exports.__esModule = true;\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-patch-ot-agent/src/json-patch-ot-agent.js\n// module id = 34\n// module chunks = 0","/*!\r\n * https://github.com/Palindrom/JSONPatchOT\r\n * JSON-Patch-OT version: 1.0.1\r\n * (c) 2017 Tomek Wytrebowicz\r\n * MIT license\r\n */\r\n\r\nvar JSONPatchOT = (function(){\r\n\r\n  var debug = false;\r\n  var JSONPatchOT = JSONPatchOT || {};\r\n  JSONPatchOT.transform = function (sequenceA, sequences) {\r\n    var concatAllSequences = [];\r\n    concatAllSequences = concatAllSequences.concat.apply(concatAllSequences, sequences);\r\n    // var clonedPatch = JSON.parse(JSON.stringify(this.patch)); // clone needed for debugging and visualization\r\n    var clonedPatch = JSON.parse(JSON.stringify(sequenceA)); // clone needed for debugging and visualization\r\n    var result = concatAllSequences.reduce(composeJSONPatches, clonedPatch); // <=> composeJSONPatches(this, operations.concat() )\r\n    return result;\r\n    // return new JSONPatchOperation(result, this.localRevision, operations[operations.length-1].localRevision, this.localRevPropName, this.remoteRevPropName);\r\n  };\r\n  JSONPatchOT.transformAgainstSingleOp = function(sequenceA, operationObj){\r\n\r\n  };\r\n  var composeJSONPatches = function( original, operationObj ){\r\n\r\n      // basic validation (as in fast-json-patch)\r\n      if (operationObj.value === undefined && (operationObj.op === \"add\" || operationObj.op === \"replace\" || operationObj.op === \"test\")) {\r\n          throw new Error(\"'value' MUST be defined\");\r\n      }\r\n      if (operationObj.from === undefined && (operationObj.op === \"copy\" || operationObj.op === \"move\")) {\r\n          throw new Error(\"'from' MUST be defined\");\r\n      }\r\n\r\n      // apply patch operation to all original ops\r\n      if(transformAgainst[operationObj.op]){ // if we have any function to transform operationObj.op at all\r\n        if(typeof transformAgainst[operationObj.op] == \"function\"){ //not perfectly performant but gives easier maintenance and flexibility with transformations\r\n          transformAgainst[operationObj.op](operationObj, original);\r\n        } else {\r\n          var orgOpsLen = original.length, currentOp = 0;\r\n          while (currentOp < orgOpsLen) {\r\n            var originalOp = original[currentOp];\r\n            currentOp++;\r\n\r\n            if( transformAgainst[operationObj.op][originalOp.op] ){\r\n              transformAgainst[operationObj.op][originalOp.op](operationObj, originalOp)\r\n            } else{\r\n              debug && console.log(\"No function to transform \" + originalOp.op + \"against\" + operationObj.op);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        debug && console.log(\"No function to transform against \" + operationObj.op)\r\n      }\r\n      return original;\r\n    };\r\n    var transformAgainst = {\r\n      remove: function(patchOp, original){\r\n        debug && console.log(\"Transforming \", JSON.stringify(original) ,\" against `remove` \", patchOp);\r\n        var orgOpsLen = original.length, currentOp = 0, originalOp;\r\n        // remove operation objects\r\n        while (originalOp = original[currentOp]) {\r\n\r\n\r\n          // TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\r\n          debug && console.log(\"TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\");\r\n          if( (originalOp.op === 'add' || originalOp.op === 'test') && patchOp.path === originalOp.path ){\r\n            // do nothing ? (tomalec)\r\n          } else\r\n          // node in question was removed\r\n          if( originalOp.from &&\r\n                  (originalOp.from === patchOp.path || originalOp.from.indexOf(patchOp.path + \"/\") === 0 ) ||\r\n              ( patchOp.path === originalOp.path || originalOp.path.indexOf(patchOp.path + \"/\") === 0 ) ){\r\n            debug && console.log(\"Removing \", originalOp);\r\n            original.splice(currentOp,1);\r\n            orgOpsLen--;\r\n            currentOp--;\r\n          }\r\n          currentOp++;\r\n        }\r\n        // shift indexes\r\n        // var match = patchOp.path.match(/(.*\\/)(\\d+)$/); // last element is a number\r\n        var lastSlash = patchOp.path.lastIndexOf(\"/\");\r\n        if( lastSlash > -1){\r\n          var index = patchOp.path.substr(lastSlash+1);\r\n          var arrayPath = patchOp.path.substr(0,lastSlash+1);\r\n          if( isValidIndex(index)){\r\n            debug && console.warn(\"Bug prone guessing that, as number given in path, this is an array!\");\r\n\r\n            debug && console.log(\"Shifting array indexes\");\r\n            orgOpsLen = original.length;\r\n            currentOp = 0;\r\n            while (currentOp < orgOpsLen) {\r\n              originalOp = original[currentOp];\r\n              currentOp++;\r\n\r\n              if(originalOp.path.indexOf(arrayPath) === 0){//item from the same array\r\n                originalOp.path = replacePathIfHigher(originalOp.path, arrayPath, index);\r\n              }\r\n              if(originalOp.from && originalOp.from.indexOf(arrayPath) === 0){//item from the same array\r\n                originalOp.from = replacePathIfHigher(originalOp.from, arrayPath, index);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      },\r\n      replace: function(patchOp, original){\r\n        debug && console.log(\"Transforming \", JSON.stringify(original) ,\" against `replace` \", patchOp);\r\n        var currentOp = 0, originalOp;\r\n        // remove operation objects withing replaced JSON node\r\n        while (originalOp = original[currentOp]) {\r\n\r\n\r\n          // TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\r\n          debug && console.log(\"TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\");\r\n          // node in question was removed\r\n          // IT:\r\n          // if( patchOp.path === originalOp.path || originalOp.path.indexOf(patchOp.path + \"/\") === 0 ){\r\n          if( originalOp.from &&\r\n                  (originalOp.from === patchOp.path || originalOp.from.indexOf(patchOp.path + \"/\") === 0 ) ||\r\n              originalOp.path.indexOf(patchOp.path + \"/\") === 0 ){\r\n            debug && console.log(\"Removing \", originalOp);\r\n            original.splice(currentOp,1);\r\n            currentOp--;\r\n          }\r\n          currentOp++;\r\n        }\r\n\r\n      }\r\n    };\r\n    function replacePathIfHigher(path, repl, index){\r\n      var result = path.substr(repl.length);\r\n      // var match = result.match(/^(\\d+)(.*)/);\r\n      // if(match && match[1] > index){\r\n      var eoindex = result.indexOf(\"/\");\r\n      eoindex > -1 || (eoindex = result.length);\r\n      var oldIndex = result.substr(0, eoindex);\r\n      var rest  = result.substr(eoindex);\r\n      if(isValidIndex(oldIndex) && oldIndex > index){\r\n        return repl + (oldIndex -1) + rest;\r\n      } else {\r\n        return path;\r\n      }\r\n    }\r\n    function isValidIndex(str) {\r\n        var n = ~~Number(str);\r\n        return String(n) === str && n >= 0;\r\n    }\r\n    return JSONPatchOT;\r\n}());\r\n\r\nif(typeof module !== 'undefined') {\r\n  module.exports = JSONPatchOT;\r\n  module.exports.default = JSONPatchOT;\r\n  module.exports.__esModule = true;\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-patch-ot/src/json-patch-ot.js\n// module id = 35\n// module chunks = 0","/**\r\n * JSON Patch Queue for synchronous operations, and asynchronous networking.\r\n * version: 3.0.0-rc.0\r\n * @param {Object} Obj The target object where patches are applied\r\n * @param {JSON-Pointer} versionPath JSON-Pointers to version numbers\r\n * @param {function} apply    apply(JSONobj, JSONPatchSequence) function to apply JSONPatch to object.\r\n * @param {Boolean} [purist]       If set to true adds test operation before replace.\r\n */\r\nvar JSONPatchQueueSynchronous = function(obj, versionPath, apply, purist){\r\n\r\n\t/**\r\n\t * The target object where patches are applied\r\n\t * @type {Object}\r\n\t */\r\n\tthis.obj = obj;\r\n\r\n\t/**\r\n\t * Queue of consecutive JSON Patch sequences. May contain gaps.\r\n\t * Item with index 0 has 1 sequence version gap to `this.version`.\r\n\t * @type {Array}\r\n\t */\r\n\tthis.waiting = [];\r\n\t/**\r\n\t * JSON-Pointer to local version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.versionPath = versionPath;\r\n\t/**\r\n\t * Function to apply JSONPatchSequence to JSON object\r\n\t * @type {Function}\r\n\t */\r\n\tthis.apply = apply;\r\n\t/**\r\n\t * If set to true adds test operation before replace.\r\n\t * @type {Bool}\r\n\t */\r\n\tthis.purist = purist;\r\n};\r\n/** JSON version */\r\nJSONPatchQueueSynchronous.prototype.version = 0;\r\n//JSONPatchQueueSynchronous.prototype.purist = false;\r\n// instance property\r\n//  JSONPatchQueueSynchronous.prototype.waiting = [];\r\n/**\r\n * Process received versioned JSON Patch.\r\n * Applies or adds to queue.\r\n * @param  {JSONPatch} versionedJsonPatch patch to be applied\r\n * @param  {Function} [applyCallback]     optional `function(object, consecutivePatch)` to be called when applied, if not given #apply will be called\r\n */\r\nJSONPatchQueueSynchronous.prototype.receive = function(versionedJsonPatch, applyCallback){\r\n\tvar apply = applyCallback || this.apply,\r\n\t\tconsecutivePatch = versionedJsonPatch.slice(0);\r\n\t// strip Versioned JSON Patch specyfiv operation objects from given sequence\r\n\t\tif(this.purist){\r\n\t\t\tvar testRemote = consecutivePatch.shift();\r\n\t\t}\r\n\t\tvar replaceVersion = consecutivePatch.shift(),\r\n\t\t\tnewVersion = replaceVersion.value;\r\n\r\n\t// TODO: perform versionedPath validation if needed (tomalec)\r\n\r\n\tif( newVersion <= this.version){\r\n\t// someone is trying to change something that was already updated\r\n    \tthrow new Error(\"Given version was already applied.\");\r\n\t} else if ( newVersion == this.version + 1 ){\r\n\t// consecutive new version\r\n\t\twhile( consecutivePatch ){// process consecutive patch(-es)\r\n\t\t\tthis.version++;\r\n\t\t\tthis.obj = apply(this.obj, consecutivePatch);\r\n\t\t\tconsecutivePatch = this.waiting.shift();\r\n\t\t}\r\n\t} else {\r\n\t// add sequence to queue in correct position.\r\n\t\tthis.waiting[newVersion - this.version -2] = consecutivePatch;\r\n\t}\r\n};\r\n/**\r\n * Wraps JSON Patch sequence with version related operation objects\r\n * @param  {JSONPatch} sequence JSON Patch sequence to wrap\r\n * @return {VersionedJSONPatch}\r\n */\r\nJSONPatchQueueSynchronous.prototype.send = function(sequence){\r\n\tthis.version++;\r\n\tvar newSequence = sequence.slice(0);\r\n\tnewSequence.unshift({\r\n\t\top: \"replace\",\r\n\t\tpath: this.versionPath,\r\n\t\tvalue: this.version\r\n\t});\r\n\tif(this.purist){\r\n\t\tnewSequence.unshift({ // test for purist\r\n\t\t\top: \"test\",\r\n\t\t\tpath: this.versionPath,\r\n\t\t\tvalue: this.version-1\r\n\t\t});\r\n\t}\r\n\treturn newSequence;\r\n};\r\n\r\nJSONPatchQueueSynchronous.getPropertyByJsonPointer = function(obj, pointer) {\r\n\tvar parts = pointer.split('/');\r\n\tif(parts[0] === \"\") {\r\n\t\tparts.shift();\r\n\t}\r\n\tvar target = obj;\r\n\twhile(parts.length) {\r\n\t\tvar path = parts.shift().replace('~1', '/').replace('~0', '~');\r\n\t\tif(parts.length) {\r\n\t\t\ttarget = target[path];\r\n\t\t}\r\n\t}\r\n\treturn target[path];\r\n};\r\n\r\n/**\r\n * Reset queue internals and object to new, given state\r\n * @param newState versioned object representing desired state along with versions\r\n */\r\nJSONPatchQueueSynchronous.prototype.reset = function(newState){\r\n\tthis.version = JSONPatchQueueSynchronous.getPropertyByJsonPointer(newState, this.versionPath);\r\n\tthis.waiting = [];\r\n\tvar patch = [{ op: \"replace\", path: \"\", value: newState }];\r\n\treturn this.obj = this.apply(this.obj, patch);\r\n};\r\n\r\nif(typeof module !== 'undefined') {\r\n\tmodule.exports = JSONPatchQueueSynchronous;\r\n\tmodule.exports.default = JSONPatchQueueSynchronous;\r\n\t/* Babel demands this */\r\n\tmodule.exports.__esModule = true;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-patch-queue/src/json-patch-queue-synchronous.js\n// module id = 36\n// module chunks = 0","/**\r\n * JSON Patch Queue for asynchronous operations, and asynchronous networking.\r\n * version: 3.0.0-rc.0\r\n * @param {Object} obj The target object where patches are applied\r\n * @param {Array<JSON-Pointer>} versionPaths JSON-Pointers to version numbers [local, remote]\r\n * @param {function} apply    apply(JSONobj, JSONPatchSequence) function to apply JSONPatch to object.\r\n * @param {Boolean} [purist]       If set to true adds test operation before replace.\r\n */\r\nvar JSONPatchQueue = function(obj, versionPaths, apply, purist){\r\n\r\n\t/**\r\n\t * The target object where patches are applied\r\n\t * @type {Object}\r\n\t */\r\n\tthis.obj = obj;\r\n\t/**\r\n\t * Queue of consecutive JSON Patch sequences. May contain gaps.\r\n\t * Item with index 0 has 1 version gap to this.remoteVersion.\r\n\t * @type {Array}\r\n\t */\r\n\tthis.waiting = [];\r\n\t/**\r\n\t * JSON-Pointer to local version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.localPath = versionPaths[0];\r\n\t/**\r\n\t * JSON-Pointer to remote version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.remotePath = versionPaths[1];\r\n\t/**\r\n\t * Function to apply JSONPatchSequence to JSON object\r\n\t * @type {Function}\r\n\t */\r\n\tthis.apply = apply;\r\n\t/**\r\n\t * If set to true adds test operation before replace.\r\n\t * @type {Bool}\r\n\t */\r\n\tthis.purist = purist;\r\n\r\n};\r\n/** local version */\r\nJSONPatchQueue.prototype.localVersion = 0;\r\n/** Latest localVersion that we know that was acknowledged by remote */\r\n// JSONPatchQueue.prototype.ackVersion = 0;\r\n/** Latest acknowledged remote version */\r\nJSONPatchQueue.prototype.remoteVersion = 0;\r\n\r\n// instance property\r\n//  JSONPatchQueue.prototype.waiting = [];\r\n/** needed? OT only? */\r\n// JSONPatchQueue.prototype.pending = [];\r\n/**\r\n * Process received versioned JSON Patch\r\n * Applies or adds to queue.\r\n * @param  {JSONPatch} versionedJsonPatch patch to be applied\r\n * @param  {Function} [applyCallback]     optional `function(object, consecutivePatch)` to be called when applied, if not given #apply will be called\r\n */\r\nJSONPatchQueue.prototype.receive = function(versionedJsonPatch, applyCallback){\r\n\tvar apply = applyCallback || this.apply,\r\n\t\tconsecutivePatch = versionedJsonPatch.slice(0);\r\n\t// strip Versioned JSON Patch specyfiv operation objects from given sequence\r\n\t\tif(this.purist){\r\n\t\t\tvar testRemote = consecutivePatch.shift();\r\n\t\t}\r\n\t\tvar replaceRemote = consecutivePatch.shift(),\r\n\t\t\tnewRemoteVersion = replaceRemote.value;\r\n\r\n\t// TODO: perform versionedPath validation if needed (tomalec)\r\n\r\n\tif( newRemoteVersion <= this.remoteVersion){\r\n\t// someone is trying to change something that was already updated\r\n    \tthrow new Error(\"Given version was already applied.\");\r\n\t} else if ( newRemoteVersion == this.remoteVersion + 1 ){\r\n\t// consecutive new version\r\n\t\twhile( consecutivePatch ){// process consecutive patch(-es)\r\n\t\t\tthis.remoteVersion++;\r\n\t\t\tthis.obj = apply(this.obj, consecutivePatch);\r\n\t\t\tconsecutivePatch = this.waiting.shift();\r\n\t\t}\r\n\t} else {\r\n\t// add sequence to queue in correct position.\r\n\t\tthis.waiting[newRemoteVersion - this.remoteVersion -2] = consecutivePatch;\r\n\t}\r\n};\r\n/**\r\n * Wraps JSON Patch sequence with version related operation objects\r\n * @param  {JSONPatch} sequence JSON Patch sequence to wrap\r\n * @return {VersionedJSONPatch}\r\n */\r\nJSONPatchQueue.prototype.send = function(sequence){\r\n\tthis.localVersion++;\r\n\tvar newSequence = sequence.slice(0);\r\n\tif(this.purist){\r\n\t\tnewSequence.unshift({ // test for consecutiveness\r\n\t\t\top: \"test\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion - 1\r\n\t\t},{ // replace for queue\r\n\t\t\top: \"replace\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion\r\n\t\t});\r\n\t} else {\r\n\t\tnewSequence.unshift({ // replace for queue (+assumed test for consecutiveness_)\r\n\t\t\top: \"replace\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion\r\n\t\t});\r\n\t}\r\n\treturn newSequence;\r\n};\r\n\r\nJSONPatchQueue.getPropertyByJsonPointer = function(obj, pointer) {\r\n\tvar parts = pointer.split('/');\r\n\tif(parts[0] === \"\") {\r\n\t\tparts.shift();\r\n\t}\r\n\tvar target = obj;\r\n\twhile(parts.length) {\r\n\t\tvar path = parts.shift().replace('~1', '/').replace('~0', '~');\r\n\t\tif(parts.length) {\r\n\t\t\ttarget = target[path];\r\n\t\t}\r\n\t}\r\n\treturn target[path];\r\n};\r\n\r\n/**\r\n * Reset queue internals and object to new, given state\r\n * @param newState versioned object representing desired state along with versions\r\n */\r\nJSONPatchQueue.prototype.reset = function(newState){\r\n\tthis.remoteVersion = JSONPatchQueue.getPropertyByJsonPointer(newState, this.remotePath);\r\n\tthis.waiting = [];\r\n\tvar patch = [{ op: \"replace\", path: \"\", value: newState }];\r\n\treturn this.obj = this.apply(this.obj, patch);\r\n};\r\n\r\nif(typeof module !== 'undefined') {\r\n\tmodule.exports = JSONPatchQueue;\r\n\tmodule.exports.default = JSONPatchQueue;\r\n\t/* Babel demands this */\r\n\tmodule.exports.__esModule = true;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-patch-queue/src/json-patch-queue.js\n// module id = 37\n// module chunks = 0","'use strict';\r\n\r\n/*!\r\n * https://github.com/Palindrom/JSONPatcherProxy\r\n * (c) 2017 Starcounter \r\n * MIT license\r\n */\r\n\r\n/** Class representing a JS Object observer  */\r\nconst JSONPatcherProxy = (function() {\r\n  /**\r\n  * Deep clones your object and returns a new object.\r\n  */\r\n  function deepClone(obj) {\r\n    switch (typeof obj) {\r\n      case 'object':\r\n        return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n      case 'undefined':\r\n        return null; //this is how JSON.stringify behaves for array items\r\n      default:\r\n        return obj; //no need to clone primitives\r\n    }\r\n  }\r\n  JSONPatcherProxy.deepClone = deepClone;\r\n\r\n  function escapePathComponent(str) {\r\n    if (str.indexOf('/') == -1 && str.indexOf('~') == -1) return str;\r\n    return str.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n  }\r\n  JSONPatcherProxy.escapePathComponent = escapePathComponent;\r\n\r\n  /**\r\n   * Walk up the parenthood tree to get the path\r\n   * @param {JSONPatcherProxy} instance \r\n   * @param {Object} obj the object you need to find its path\r\n   */\r\n  function findObjectPath(instance, obj) {\r\n    const pathComponents = [];\r\n    let parentAndPath = instance.parenthoodMap.get(obj);\r\n    while (parentAndPath && parentAndPath.path) {\r\n      // because we're walking up-tree, we need to use the array as a stack\r\n      pathComponents.unshift(parentAndPath.path);\r\n      parentAndPath = instance.parenthoodMap.get(parentAndPath.parent);\r\n    }\r\n    if (pathComponents.length) {\r\n      const path = pathComponents.join('/');\r\n      return '/' + path;\r\n    }\r\n    return '';\r\n  }\r\n  /**\r\n   * A callback to be used as th proxy set trap callback.\r\n   * It updates parenthood map if needed, proxifies nested newly-added objects, calls default callbacks with the changes occurred.\r\n   * @param {JSONPatcherProxy} instance JSONPatcherProxy instance\r\n   * @param {Object} target the affected object\r\n   * @param {String} key the effect property's name\r\n   * @param {Any} newValue the value being set\r\n   */\r\n  function setTrap(instance, target, key, newValue) {\r\n    const parentPath = findObjectPath(instance, target);\r\n\r\n    const destinationPropKey = parentPath + '/' + escapePathComponent(key);\r\n\r\n    if (instance.proxifiedObjectsMap.has(newValue)) {\r\n      const newValueOriginalObject = instance.proxifiedObjectsMap.get(newValue);\r\n\r\n      instance.parenthoodMap.set(newValueOriginalObject.originalObject, {\r\n        parent: target,\r\n        path: key\r\n      });\r\n    }\r\n    /*\r\n        mark already proxified values as inherited.\r\n        rationale: proxy.arr.shift()\r\n        will emit\r\n        {op: replace, path: '/arr/1', value: arr_2}\r\n        {op: remove, path: '/arr/2'}\r\n\r\n        by default, the second operation would revoke the proxy, and this renders arr revoked.\r\n        That's why we need to remember the proxies that are inherited.\r\n      */\r\n    const revokableInstance = instance.proxifiedObjectsMap.get(newValue);\r\n    /*\r\n    Why do we need to check instance.isProxifyingTreeNow?\r\n\r\n    We need to make sure we mark revokables as inherited ONLY when we're observing,\r\n    because throughout the first proxification, a sub-object is proxified and then assigned to \r\n    its parent object. This assignment of a pre-proxified object can fool us into thinking\r\n    that it's a proxified object moved around, while in fact it's the first assignment ever. \r\n\r\n    Checking isProxifyingTreeNow ensures this is not happening in the first proxification, \r\n    but in fact is is a proxified object moved around the tree\r\n    */\r\n    if (revokableInstance && !instance.isProxifyingTreeNow) {\r\n      revokableInstance.inherited = true;\r\n    }\r\n\r\n    // if the new value is an object, make sure to watch it\r\n    if (\r\n      newValue &&\r\n      typeof newValue == 'object' &&\r\n      !instance.proxifiedObjectsMap.has(newValue)\r\n    ) {\r\n      instance.parenthoodMap.set(newValue, {\r\n        parent: target,\r\n        path: key\r\n      });\r\n      newValue = instance._proxifyObjectTreeRecursively(target, newValue, key);\r\n    }\r\n    // let's start with this operation, and may or may not update it later\r\n    const operation = {\r\n      op: 'remove',\r\n      path: destinationPropKey\r\n    };\r\n    if (typeof newValue == 'undefined') {\r\n      // applying De Morgan's laws would be a tad faster, but less readable\r\n      if (!Array.isArray(target) && !target.hasOwnProperty(key)) {\r\n        // `undefined` is being set to an already undefined value, keep silent\r\n        return Reflect.set(target, key, newValue);\r\n      } else {\r\n        // when array element is set to `undefined`, should generate replace to `null`\r\n        if (Array.isArray(target)) {\r\n          // undefined array elements are JSON.stringified to `null`\r\n          (operation.op = 'replace'), (operation.value = null);\r\n        }\r\n        const oldValue = instance.proxifiedObjectsMap.get(target[key]);\r\n        // was the deleted a proxified object?\r\n        if (oldValue) {\r\n          instance.parenthoodMap.delete(target[key]);\r\n          instance.disableTrapsForProxy(oldValue);\r\n          instance.proxifiedObjectsMap.delete(oldValue);\r\n        }\r\n      }\r\n    } else {\r\n      if (Array.isArray(target) && !Number.isInteger(+key.toString())) {\r\n        /* array props (as opposed to indices) don't emit any patches, to avoid needless `length` patches */\r\n        return Reflect.set(target, key, newValue);\r\n      }\r\n      operation.op = 'add';\r\n      if (target.hasOwnProperty(key)) {\r\n        if (typeof target[key] !== 'undefined' || Array.isArray(target)) {\r\n          operation.op = 'replace'; // setting `undefined` array elements is a `replace` op\r\n        }\r\n      }\r\n      operation.value = newValue;\r\n    }\r\n    const reflectionResult = Reflect.set(target, key, newValue);\r\n    instance.defaultCallback(operation);\r\n    return reflectionResult;\r\n  }\r\n  /**\r\n   * A callback to be used as th proxy delete trap callback.\r\n   * It updates parenthood map if needed, calls default callbacks with the changes occurred.\r\n   * @param {JSONPatcherProxy} instance JSONPatcherProxy instance\r\n   * @param {Object} target the effected object\r\n   * @param {String} key the effected property's name\r\n   */\r\n  function deleteTrap(instance, target, key) {\r\n    if (typeof target[key] !== 'undefined') {\r\n      const parentPath = findObjectPath(instance, target);\r\n      const destinationPropKey = parentPath + '/' + escapePathComponent(key);\r\n\r\n      const revokableProxyInstance = instance.proxifiedObjectsMap.get(\r\n        target[key]\r\n      );\r\n\r\n      if (revokableProxyInstance) {\r\n        if (revokableProxyInstance.inherited) {\r\n          /*\r\n            this is an inherited proxy (an already proxified object that was moved around), \r\n            we shouldn't revoke it, because even though it was removed from path1, it is still used in path2.\r\n            And we know that because we mark moved proxies with `inherited` flag when we move them\r\n\r\n            it is a good idea to remove this flag if we come across it here, in deleteProperty trap.\r\n            We DO want to revoke the proxy if it was removed again.\r\n          */\r\n          revokableProxyInstance.inherited = false;\r\n        } else {\r\n          instance.parenthoodMap.delete(revokableProxyInstance.originalObject);\r\n          instance.disableTrapsForProxy(revokableProxyInstance);\r\n          instance.proxifiedObjectsMap.delete(target[key]);\r\n        }\r\n      }\r\n      const reflectionResult = Reflect.deleteProperty(target, key);\r\n\r\n      instance.defaultCallback({\r\n        op: 'remove',\r\n        path: destinationPropKey\r\n      });\r\n\r\n      return reflectionResult;\r\n    }\r\n  }\r\n  /* pre-define resume and pause functions to enhance constructors performance */\r\n  function resume() {\r\n    this.defaultCallback = operation => {\r\n      this.isRecording && this.patches.push(operation);\r\n      this.userCallback && this.userCallback(operation);\r\n    };\r\n    this.isObserving = true;\r\n  }\r\n  function pause() {\r\n    this.defaultCallback = () => {};\r\n    this.isObserving = false;\r\n  }\r\n  /**\r\n    * Creates an instance of JSONPatcherProxy around your object of interest `root`. \r\n    * @param {Object|Array} root - the object you want to wrap\r\n    * @param {Boolean} [showDetachedWarning = true] - whether to log a warning when a detached sub-object is modified @see {@link https://github.com/Palindrom/JSONPatcherProxy#detached-objects} \r\n    * @returns {JSONPatcherProxy}\r\n    * @constructor\r\n    */\r\n  function JSONPatcherProxy(root, showDetachedWarning) {\r\n    this.isProxifyingTreeNow = false;\r\n    this.isObserving = false;\r\n    this.proxifiedObjectsMap = new Map();\r\n    this.parenthoodMap = new Map();\r\n    // default to true\r\n    if (typeof showDetachedWarning !== 'boolean') {\r\n      showDetachedWarning = true;\r\n    }\r\n\r\n    this.showDetachedWarning = showDetachedWarning;\r\n    this.originalObject = root;\r\n    this.cachedProxy = null;\r\n    this.isRecording = false;\r\n    this.userCallback;\r\n    /**\r\n     * @memberof JSONPatcherProxy\r\n     * Restores callback back to the original one provided to `observe`.\r\n     */\r\n    this.resume = resume.bind(this);\r\n    /**\r\n     * @memberof JSONPatcherProxy\r\n     * Replaces your callback with a noop function.\r\n     */\r\n    this.pause = pause.bind(this);\r\n  }\r\n\r\n  JSONPatcherProxy.prototype.generateProxyAtPath = function(parent, obj, path) {\r\n    if (!obj) {\r\n      return obj;\r\n    }\r\n    const traps = {\r\n      set: (target, key, value, receiver) =>\r\n        setTrap(this, target, key, value, receiver),\r\n      deleteProperty: (target, key) => deleteTrap(this, target, key)\r\n    };\r\n    const revocableInstance = Proxy.revocable(obj, traps);\r\n    // cache traps object to disable them later.\r\n    revocableInstance.trapsInstance = traps;\r\n    revocableInstance.originalObject = obj;\r\n\r\n    /* keeping track of object's parent and path */\r\n\r\n    this.parenthoodMap.set(obj, { parent, path });\r\n\r\n    /* keeping track of all the proxies to be able to revoke them later */\r\n    this.proxifiedObjectsMap.set(revocableInstance.proxy, revocableInstance);\r\n    return revocableInstance.proxy;\r\n  };\r\n  // grab tree's leaves one by one, encapsulate them into a proxy and return\r\n  JSONPatcherProxy.prototype._proxifyObjectTreeRecursively = function(\r\n    parent,\r\n    root,\r\n    path\r\n  ) {\r\n    for (let key in root) {\r\n      if (root.hasOwnProperty(key)) {\r\n        if (root[key] instanceof Object) {\r\n          root[key] = this._proxifyObjectTreeRecursively(\r\n            root,\r\n            root[key],\r\n            escapePathComponent(key)\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return this.generateProxyAtPath(parent, root, path);\r\n  };\r\n  // this function is for aesthetic purposes\r\n  JSONPatcherProxy.prototype.proxifyObjectTree = function(root) {\r\n    /*\r\n    while proxyifying object tree,\r\n    the proxyifying operation itself is being\r\n    recorded, which in an unwanted behavior,\r\n    that's why we disable recording through this\r\n    initial process;\r\n    */\r\n    this.pause();\r\n    this.isProxifyingTreeNow = true;\r\n    const proxifiedObject = this._proxifyObjectTreeRecursively(\r\n      undefined,\r\n      root,\r\n      ''\r\n    );\r\n    /* OK you can record now */\r\n    this.isProxifyingTreeNow = false;\r\n    this.resume();\r\n    return proxifiedObject;\r\n  };\r\n  /**\r\n   * Turns a proxified object into a forward-proxy object; doesn't emit any patches anymore, like a normal object\r\n   * @param {Proxy} proxy - The target proxy object\r\n   */\r\n  JSONPatcherProxy.prototype.disableTrapsForProxy = function(\r\n    revokableProxyInstance\r\n  ) {\r\n    if (this.showDetachedWarning) {\r\n      const message =\r\n        \"You're accessing an object that is detached from the observedObject tree, see https://github.com/Palindrom/JSONPatcherProxy#detached-objects\";\r\n\r\n      revokableProxyInstance.trapsInstance.set = (\r\n        targetObject,\r\n        propKey,\r\n        newValue\r\n      ) => {\r\n        console.warn(message);\r\n        return Reflect.set(targetObject, propKey, newValue);\r\n      };\r\n      revokableProxyInstance.trapsInstance.set = (\r\n        targetObject,\r\n        propKey,\r\n        newValue\r\n      ) => {\r\n        console.warn(message);\r\n        return Reflect.set(targetObject, propKey, newValue);\r\n      };\r\n      revokableProxyInstance.trapsInstance.deleteProperty = (\r\n        targetObject,\r\n        propKey\r\n      ) => {\r\n        return Reflect.deleteProperty(targetObject, propKey);\r\n      };\r\n    } else {\r\n      delete revokableProxyInstance.trapsInstance.set;\r\n      delete revokableProxyInstance.trapsInstance.get;\r\n      delete revokableProxyInstance.trapsInstance.deleteProperty;\r\n    }\r\n  };\r\n  /**\r\n   * Proxifies the object that was passed in the constructor and returns a proxified mirror of it. Even though both parameters are options. You need to pass at least one of them.\r\n   * @param {Boolean} [record] - whether to record object changes to a later-retrievable patches array.\r\n   * @param {Function} [callback] - this will be synchronously called with every object change with a single `patch` as the only parameter.\r\n   */\r\n  JSONPatcherProxy.prototype.observe = function(record, callback) {\r\n    if (!record && !callback) {\r\n      throw new Error('You need to either record changes or pass a callback');\r\n    }\r\n    this.isRecording = record;\r\n    this.userCallback = callback;\r\n    /*\r\n    I moved it here to remove it from `unobserve`,\r\n    this will also make the constructor faster, why initiate\r\n    the array before they decide to actually observe with recording?\r\n    They might need to use only a callback.\r\n    */\r\n    if (record) this.patches = [];\r\n    this.cachedProxy = this.proxifyObjectTree(this.originalObject);\r\n    return this.cachedProxy;\r\n  };\r\n  /**\r\n   * If the observed is set to record, it will synchronously return all the patches and empties patches array.\r\n   */\r\n  JSONPatcherProxy.prototype.generate = function() {\r\n    if (!this.isRecording) {\r\n      throw new Error('You should set record to true to get patches later');\r\n    }\r\n    return this.patches.splice(0, this.patches.length);\r\n  };\r\n  /**\r\n   * Revokes all proxies rendering the observed object useless and good for garbage collection @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable}\r\n   */\r\n  JSONPatcherProxy.prototype.revoke = function() {\r\n    this.proxifiedObjectsMap.forEach(el => {\r\n      el.revoke();\r\n    });\r\n  };\r\n  /**\r\n   * Disables all proxies' traps, turning the observed object into a forward-proxy object, like a normal object that you can modify silently.\r\n   */\r\n  JSONPatcherProxy.prototype.disableTraps = function() {\r\n    this.proxifiedObjectsMap.forEach(this.disableTrapsForProxy, this);\r\n  };\r\n  return JSONPatcherProxy;\r\n})();\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = JSONPatcherProxy;\r\n  module.exports.default = JSONPatcherProxy;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jsonpatcherproxy/src/jsonpatcherproxy.js\n// module id = 38\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 39\n// module chunks = 0","module.exports = {\"name\":\"palindrom\",\"version\":\"3.0.9\",\"description\":\"\",\"license\":\"MIT\",\"homepage\":\"https://github.com/palindrom/Palindrom\",\"keywords\":[\"json\",\"patch\",\"http\",\"rest\"],\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/Palindrom/Palindrom.git\"},\"bugs\":{\"url\":\"https://github.com/Palindrom/Palindrom/issues\"},\"author\":{\"name\":\"Joachim Wester\",\"email\":\"joachimwester@me.com\",\"url\":\"http://www.starcounter.com/\"},\"licenses\":[{\"type\":\"MIT\",\"url\":\"http://www.opensource.org/licenses/MIT\"}],\"main\":\"./src/palindrom.js\",\"dependencies\":{\"axios\":\"^0.15.3\",\"events\":\"^1.1.1\",\"fast-json-patch\":\"^2.0.5\",\"json-patch-ot\":\"^1.0.1\",\"json-patch-ot-agent\":\"2.0.0-rc.0\",\"jsonpatcherproxy\":\"^0.0.9\",\"url\":\"^0.11.0\",\"websocket\":\"^1.0.24\"},\"devDependencies\":{\"babili-webpack-plugin\":\"^0.1.1\",\"bluebird\":\"^3.5.0\",\"bluebird-retry\":\"^0.10.1\",\"chai\":\"^3.5.0\",\"colors\":\"^1.1.2\",\"jasmine\":\"^2.4.0\",\"json-loader\":\"^0.5.4\",\"mocha\":\"^3.2.0\",\"mock-socket\":\"6.0.4\",\"moxios\":\"^0.3.0\",\"polyserve\":\"^0.16.0\",\"saucelabs\":\"^1.4.0\",\"selenium-webdriver\":\"^3.3.0\",\"sinon\":\"^2.1.0\",\"webpack\":\"^2.7.0\"},\"scripts\":{\"version\":\"webpack && git add -A\",\"test-sauce\":\"webpack && node test/Sauce/Runner.js\",\"test\":\"mocha test/runner.js\",\"test-full\":\"mocha test/runner.js && webpack && node test/Sauce/Runner.js\",\"build\":\"webpack\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 40\n// module chunks = 0","/*! Palindrom\r\n * https://github.com/Palindrom/Palindrom\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nconst Palindrom = require('./palindrom');\r\n\r\nconst PalindromDOM = (() => {\r\n  /**\r\n   * PalindromDOM\r\n   * @extends {Palindrom}\r\n   * @param {Object} [options] map of arguments. See README.md for description\r\n   */\r\n  class PalindromDOM extends Palindrom {\r\n    constructor(options) {\r\n      if (typeof options !== 'object') {\r\n        throw new Error(\r\n          'PalindromDOM constructor requires an object argument.'\r\n        );\r\n      }\r\n      if (!options.remoteUrl) {\r\n        throw new Error('remoteUrl is required');\r\n      }\r\n      const onStateReset = options.onStateReset || options.callback;\r\n      if (options.callback) {\r\n        console.warn(\r\n          'Palindrom: options.callback is deprecated. Please use `onStateReset` instead'\r\n        );\r\n      }\r\n\r\n      options.onStateReset = function addDOMListeners(obj) {\r\n        this.listen();\r\n        onStateReset && onStateReset.call(this, obj);\r\n      };\r\n\r\n      // construct Palindrom\r\n      super(options);\r\n\r\n      this.element = options.listenTo || document.body;\r\n      this.clickHandler = this.clickHandler.bind(this);\r\n      this.historyHandler = this.historyHandler.bind(this);\r\n\r\n      this.historyHandlerDeprecated = () => {\r\n        console.warn(\r\n          \"`puppet-redirect-pushstate` event is deprecated, please use `palindrom-redirect-pushstate`, if you're using `puppet-redirect`, please upgrade to `palindrom-redirect`\"\r\n        );\r\n        this.historyHandler();\r\n      };\r\n\r\n      /* in some cases, people emit redirect requests before `listen` is called */\r\n      this.element.addEventListener(\r\n        'palindrom-redirect-pushstate',\r\n        this.historyHandler\r\n      );\r\n      /* backward compatibility: for people using old puppet-redirect */\r\n      this.element.addEventListener(\r\n        'puppet-redirect-pushstate',\r\n        this.historyHandlerDeprecated\r\n      );\r\n    }\r\n\r\n    listen() {\r\n      this.listening = true;\r\n      this.element.addEventListener('click', this.clickHandler);\r\n      window.addEventListener('popstate', this.historyHandler); //better here than in constructor, because Chrome triggers popstate on page load\r\n\r\n      this.element.addEventListener(\r\n        'palindrom-redirect-pushstate',\r\n        this.historyHandler\r\n      );\r\n\r\n      /* backward compatibility: for people using old puppet-redirect */\r\n      this.element.addEventListener(\r\n        'puppet-redirect-pushstate',\r\n        this.historyHandlerDeprecated\r\n      );\r\n    }\r\n    unlisten() {\r\n      this.listening = false;\r\n\r\n      this.element.removeEventListener('click', this.clickHandler);\r\n      window.removeEventListener('popstate', this.historyHandler); //better here than in constructor, because Chrome triggers popstate on page load\r\n      this.element.removeEventListener(\r\n        'palindrom-redirect-pushstate',\r\n        this.historyHandler\r\n      );\r\n\r\n      /* backward compatibility: for people using old puppet-redirect */\r\n      this.element.removeEventListener(\r\n        'puppet-redirect-pushstate',\r\n        this.historyHandlerDeprecated\r\n      );\r\n    }\r\n\r\n    //TODO move fallback to window.location.href from PalindromNetworkChannel to here (PalindromDOM)\r\n\r\n    /**\r\n     * DISABLED FOR NOW: we don't know when rendering actually finishes.\r\n     * It's left here for the hope of having synchronous rendering at some point in the future.\r\n     * ====\r\n     * we need to scroll asynchronously, because we need the document rendered to search for the anchored element\r\n     * and even though onReceive + applyPatch are sync, Polymer is not, it renders async-ly\r\n    PalindromDOM.prototype.scrollToAnchorOrTopAsync = function(link) {\r\n      this.scrollAsyncTimeout && clearTimeout(this.scrollAsyncTimeout);\r\n      if (window && window.document) {\r\n        var anchorIndex;\r\n        var anchor;\r\n        // does the URL have an anchor\r\n        if (link && (anchorIndex = link.indexOf('#')) > -1) {\r\n          anchor = link.substr(anchorIndex);\r\n        }\r\n        if (!anchor) {\r\n          window.scrollTo(0, 0);\r\n        } else {\r\n          // if somehow someone manages to navigate twice in a 100ms,\r\n          // we don't scroll for their first navigation, i.e de-bouncing \r\n          \r\n          this.scrollAsyncTimeout = setTimeout(() => {\r\n            // does that anchor exist in the page?\r\n            const anchorTarget = document.querySelector(anchor); // look for #element-id\r\n            if (anchorTarget) {\r\n              anchorTarget.scrollIntoView();\r\n            } else {\r\n              window.scrollTo(0, 0);\r\n            }\r\n          }, 100);\r\n        }\r\n      }\r\n    };\r\n    */\r\n    /**\r\n     * Push a new URL to the browser address bar and send a patch request (empty or including queued local patches)\r\n     * so that the URL handlers can be executed on the remote\r\n     * @param url\r\n     */\r\n    morphUrl(url) {\r\n      history.pushState(null, null, url);\r\n      this.network.getPatchUsingHTTP(url);\r\n      window && window.scrollTo(0, 0);\r\n    }\r\n\r\n    clickHandler(event) {\r\n      //Don't morph ctrl/cmd + click & middle mouse button\r\n      if (event.ctrlKey || event.metaKey || event.which == 2) {\r\n        return;\r\n      }\r\n\r\n      if (event.detail && event.detail.target) {\r\n        //detail is Polymer\r\n        event = event.detail;\r\n      }\r\n\r\n      let target = event.target;\r\n\r\n      if (target.nodeName !== 'A') {\r\n        for (let i = 0; i < event.path.length; i++) {\r\n          if (event.path[i].nodeName == 'A') {\r\n            target = event.path[i];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      const anchorTarget = target.target || target.getAttribute('target');\r\n\r\n      if (!anchorTarget || anchorTarget === '_self') {\r\n        //needed since Polymer 0.2.0 in Chrome stable / Web Plaftorm features disabled\r\n        //because target.href returns undefined for <polymer-ui-menu-item href=\"...\"> (which is an error)\r\n        //while target.getAttribute(\"href\") returns desired href (as string)\r\n        const href = target.href || target.getAttribute('href');\r\n        if (href && PalindromDOM.isApplicationLink(href)) {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          this.morphUrl(href);\r\n        } else if (target.type === 'submit') {\r\n          event.preventDefault();\r\n        }\r\n      }\r\n    }\r\n\r\n    historyHandler() /*event*/ {\r\n      this.network.getPatchUsingHTTP(location.href);\r\n    }\r\n\r\n    /**\r\n     * Returns information if a given element is an internal application link that Palindrom should intercept into a history push\r\n     * @param elem HTMLElement or String\r\n     * @returns {boolean}\r\n     */\r\n    static isApplicationLink(elem) {\r\n      if (typeof elem === 'string') {\r\n        //type string is reported in Polymer / Canary (Web Platform features disabled)\r\n        const parser = document.createElement('A');\r\n        parser.href = elem;\r\n\r\n        // @see http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\r\n        // IE doesn't populate all link properties when setting .href with a relative URL,\r\n        // however .href will return an absolute URL which then can be used on itself\r\n        // to populate these additional fields.\r\n        if (parser.host == '') {\r\n          parser.href = parser.href;\r\n        }\r\n\r\n        elem = parser;\r\n      }\r\n      return (\r\n        elem.protocol == window.location.protocol &&\r\n        elem.host == window.location.host\r\n      );\r\n    }\r\n  }\r\n\r\n  PalindromDOM.prototype = Object.create(Palindrom.prototype);\r\n\r\n  /* backward compatibility, not sure if this is good practice */\r\n  if (typeof global === 'undefined') {\r\n    if (typeof window !== 'undefined') {\r\n      /* incase neither window nor global existed, e.g React Native */\r\n      var global = window;\r\n    } else {\r\n      var global = {};\r\n    }\r\n  }\r\n  global.PuppetDOM = PalindromDOM;\r\n\r\n  /* Since we have Palindrom bundled,\r\n  let's expose it in case anyone needs it */\r\n  global.Puppet = Palindrom;\r\n  global.Palindrom = Palindrom;\r\n\r\n  return PalindromDOM;\r\n})();\r\n\r\nmodule.exports = PalindromDOM;\r\nmodule.exports.default = PalindromDOM;\r\nmodule.exports.__esModule = true;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/palindrom-dom.js\n// module id = 41\n// module chunks = 0","module.exports = URL;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"URL\"\n// module id = 42\n// module chunks = 0","module.exports = WebSocket;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"WebSocket\"\n// module id = 43\n// module chunks = 0"],"sourceRoot":""}